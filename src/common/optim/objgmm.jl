

function MomentŒ∏1!( 
    fgh                                 :: GMMMarketFGH{T},
    Œ∏                                   :: A1{T},  
    e                                   :: GrumpsGMM, 
    d                                   :: GrumpsMarketData{T}, 
    ùí¶m                                  :: AA2{T},
    o                                   :: OptimizationOptions,
    s                                   :: GrumpsSpace{T},
    computeF                            :: Bool,
    computeG                            :: Bool,
    m                                   :: Int
    ) where {T<:Flt}

    recompute =  s.currentŒ∏ ‚â† Œ∏ || memsave( o )

    memslot = recompute ? AŒ∏ZXŒ∏!( Œ∏, e, d, o, s, m ) : m
    ms = s.marketspace[memslot]
    Œ¥ = ùìèùìà( T, dimŒ¥( d ) )

    # if recompute
        ms.microspace.lastŒ¥ .= typemax( T )
        ms.macrospace.lastŒ¥ .= typemax( T )
        grumpsŒ¥!( fgh.inside, Œ∏, Œ¥, e, d, o, ms, m )      # compute Œ¥s in the inner loop and store them in s.Œ¥
    # else
        # @warn "did not recompute Œ¥"
    # end
    

    # if computeG || computeH || !inisout( e )
       F = OutsideMoment1!(  fgh, Œ∏, Œ¥, e, d, ùí¶m, o, ms, computeF, computeG )
    # end

    freeAŒ∏ZXŒ∏!( e, s, o, memslot )
    return nothing

end



function ObjectiveFunctionŒ∏!( 
    fgh         :: GMMFGH{T}, 
    F           :: FType{T},
    Garg        :: GType{T},
    H           :: HType{T},      
    Œ∏tr         :: Vec{ T }, 
    e           :: GrumpsGMM, 
    d           :: GrumpsData{T}, 
    o           :: OptimizationOptions,
    s           :: GrumpsSpace{T} 
    ) where {T<:Flt}

    Œ∏ = getŒ∏( Œ∏tr, d )

    computeF, computeG, computeH = computewhich( F, Garg, H )


    
    markets = 1:dimM( d )
    ranges = Ranges( dimŒ¥m( d ) )

    @threads :dynamic for m ‚àà markets
        MomentŒ∏1!( 
            fgh.market[m],
            Œ∏,
            e, 
            d.marketdata[m], 
            view( d.plmdata.ùí¶, ranges[m], : ),
            o,
            s,
            computeF,
            computeG,
            m                              
            ) 
    end
    copyto!( s.currentŒ∏, Œ∏ )                                         # copy the current Œ∏

    mom = sum( fgh.market[m].mom for m ‚àà markets )
    if computeF
        F = dot( mom, mom )
    end

    if !computeG && !computeH
        return F
    end


    Œ¥Œ∏ = Vec{ Mat{T} }( undef, markets[end] )
    insides = 1:dimŒ¥( d )
    parameters = 1:dimŒ∏( d )

    @threads :dynamic for m ‚àà markets
        Œ¥Œ∏[m] = - fgh.market[m].inside.HŒ¥Œ¥ \ fgh.market[m].inside.HŒ¥Œ∏
    end

    momdŒ∏ = sum( fgh.market[m].momdŒ∏ for m ‚àà markets )
    cross = sum( fgh.market[m].momdŒ¥ * Œ¥Œ∏[m] for m ‚àà markets )
    both = momdŒ∏ + cross

    G = 2.0 * both'  * mom


    if computeH
        H[:,:] = 2.0 * both' * both
    end

    ExponentiationCorrection!( G, H, Œ∏, dimŒ∏z( d ) )

    if computeG
        copyto!( Garg, G )
    end

    return F
end

