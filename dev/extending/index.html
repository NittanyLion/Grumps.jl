<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extending Grumps · Grumps.jl</title><meta name="title" content="Extending Grumps · Grumps.jl"/><meta property="og:title" content="Extending Grumps · Grumps.jl"/><meta property="twitter:title" content="Extending Grumps · Grumps.jl"/><meta name="description" content="Documentation for Grumps.jl."/><meta property="og:description" content="Documentation for Grumps.jl."/><meta property="twitter:description" content="Documentation for Grumps.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Grumps.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../estimators/">Estimators</a></li><li><a class="tocitem" href="../quickstart/">Quick start</a></li><li><a class="tocitem" href="../objects/">User interface</a></li><li><a class="tocitem" href="../spreadsheet/">Spreadsheet formats</a></li><li><a class="tocitem" href="../example/">Example program</a></li><li><a class="tocitem" href="../tutorial/">Charlie&#39;s tutorial</a></li><li><a class="tocitem" href="../speedmemory/">Speed, memory, accuracy</a></li><li><a class="tocitem" href="../bearinmind/">Things to bear in mind</a></li><li class="is-active"><a class="tocitem" href>Extending Grumps</a><ul class="internal"><li><a class="tocitem" href="#Examining-output-at-each-iteration"><span>Examining output at each iteration</span></a></li><li><a class="tocitem" href="#User-specified-interactions"><span>User-specified interactions</span></a></li><li><a class="tocitem" href="#Adding-a-new-estimator"><span>Adding a new estimator</span></a></li><li><a class="tocitem" href="#Adding-an-integrator"><span>Adding an integrator</span></a></li></ul></li><li><a class="tocitem" href="../aliens/">Languages other than Julia</a></li><li><a class="tocitem" href="../structure/">Directory structure</a></li><li><a class="tocitem" href="../flow/">Algorithm flow</a></li><li><a class="tocitem" href="../misc/">Miscellanea</a></li><li><a class="tocitem" href="../acknowledgments/">Acknowledgments</a></li><li><a class="tocitem" href="../license/">License</a></li><li><a class="tocitem" href="../versions/">Versions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Extending Grumps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Extending Grumps</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NittanyLion/Grumps.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NittanyLion/Grumps.jl/blob/main/docs/src/extending.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Extending-Grumps"><a class="docs-heading-anchor" href="#Extending-Grumps">Extending Grumps</a><a id="Extending-Grumps-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-Grumps" title="Permalink"></a></h1><p>Grumps can be extended in multiple ways.  Below three possibilities are discussed, namely using an existing estimator for a different data format, introducing a new <em>estimator</em>, and introducing a new <em>integrator</em>.</p><h2 id="Examining-output-at-each-iteration"><a class="docs-heading-anchor" href="#Examining-output-at-each-iteration">Examining output at each iteration</a><a id="Examining-output-at-each-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Examining-output-at-each-iteration" title="Permalink"></a></h2><p>On each iteration of both the inner and outer optimization steps, Grumps calls a callback function.  By default the callback for the inner optimization does nothing and the callback for the outer optimization prints a summary of progress.  Users can add to this by defining their own callback functions named <code>δcallback</code> and <code>θcallback</code> respectively.  These are called before Grumps continues with its own callback routine.  </p><p>To do this, one has to pass an <code>id</code> to <a href="../objects/#Grumps.OptimizationOptions-Tuple{}"><code>OptimizationOptions()</code></a> and define a callback that is specifically for this id.  The id should be a symbol, i.e. a word preceded by a colon.  For instance, one can specify <code>id = :myid</code> and define the callback</p><pre><code class="nohighlight hljs">    function Grumps.θcallback( ::Val{ :myid }, statevec, e, d, o, oldx, repeatx, solution ) 

        println( &quot;hi&quot; )
        
    end</code></pre><p>Then include <code>o = OptimizationOptions(; id = :myid )</code> (possibly with other options) in the program and pass <code>o</code> as an argument to <code>grumps!</code>.</p><p>This will print &quot;hi&quot; on every <span>$θ$</span> iteration.  The first argument of <code>Grumps.θcallback</code> specifies which id this callback refers to (in case there is more than one), <code>statevec</code> is the state vector of the <code>Optim</code> package (see the documentation of that package for details), <code>oldx</code> is the <span>$θ$</span>-vector value of the previous iteration, and <code>repeatx</code> is a single element vector that indicates how often the same value of the parameter vector has been repeated.  Messing with the values of the arguments is not recommended.  The <code>Grumps.δcallback</code> function has the same syntax but lacks the <code>solution</code> argument.</p><p>If the <code>id</code> variable is set but no user callbacks are defined then Grumps will only execute the default callbacks.</p><div class="admonition is-info"><header class="admonition-header">Do not overuse Grumps.δcallback</header><div class="admonition-body"><p>If one has many markets then the δ callback is called <em>a lot</em>. Be prepared for a lot of output.  The θ callback is not called nearly as often.</p></div></div><h2 id="User-specified-interactions"><a class="docs-heading-anchor" href="#User-specified-interactions">User-specified interactions</a><a id="User-specified-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#User-specified-interactions" title="Permalink"></a></h2><p>The format of Grumps is limited to specifications that are linear in parameters.  This cannot be altered.  </p><p>The standard way that data are entered moreover presumes that there are only interactions of demographics and product level variables, interactions of random coefficients and product level variables, product level regressors (where product level regressors can include a constant), a quality variable <span>$\xi$</span>, and an error term <span>$\epsilon$</span>.  This <em>can be changed</em>.  There are three ways of accomplishing this, which are described below in increasing order of complexity.</p><div class="admonition is-success"><header class="admonition-header">Try the simplest version first</header><div class="admonition-body"><p>The other versions have advantages but are more hassle.</p></div></div><h3 id="Simplest-version"><a class="docs-heading-anchor" href="#Simplest-version">Simplest version</a><a id="Simplest-version-1"></a><a class="docs-heading-anchor-permalink" href="#Simplest-version" title="Permalink"></a></h3><p>In the simplest version, one defines a callback function called <em>InteractionsCallback</em> of the form described below.  The matrix <span>$z$</span> contains the consumer interactions and the matrix <span>$x$</span> the products; in both cases, the second argument is the regressor indicator. The function <em>InteractionsCallback</em> should return the value of the <span>$t$</span>-th interaction term for consumer <span>$i$</span> and product <span>$j$</span>.  The default value is <code>z[i,t] * x[j,t]</code>, i.e. product interactions.  So if one returned <code>exp( z[i,t] + x[j,t] )</code> if <span>$t = 1$</span> then that would replace the default first interaction term.</p><pre><code class="nohighlight hljs">    function InteractionsCallback( z, x, i, j, t, micmac, market, products ) 
        if t &gt; 1 
            return z[ i, t ] * x[ j, t ]
        end
        return exp( z[ i, t ] + x[ j, t ] )
    end</code></pre><p>The <code>micmac</code> argument indicates whether the callback is called for the interactions in the micro portion (<code>:micro</code>) or the macro portion (<code>:macro</code>) of the likelihood.  By default, Grumps creates micro interactions only at the very beginning and macro interactions only during optimization.  The <code>market</code> argument passes the name of the market and <code>products</code> a vector with product names in the order in which they are passed, albeit that the products list is only passed if <code>micmac = :micro</code>.  These are mostly useful if one wishes to incorporate some external data.  </p><p>In the example below, the list of products is stored in the <code>Dict</code> in <code>productlist[1]</code> during the <code>:micro</code> phase, which can then be used during subsequent calls.  This can be helpful to identify which product is product <code>j</code>. A downside of the simplest approach in this case is that it creates overhead, which can be avoided if one uses the bang version, described below.</p><pre><code class="nohighlight hljs">    const productlist = [ Dict{String,Vector{String}}() ]

    function InteractionsCallback( z, x, i, j, t, micmac, market, products ) 
        if micmac == :micro 
            if !haskey( productlist[1], market )
                productlist[1][ market ] = vcat( products, &quot;outside good&quot; )
            end
        end
        print( &quot;do something with product &quot; )
        printstyled(  productlist[1][ market ][j] ; color = :yellow )
        print( &quot; in the market called &quot;)
        printstyled( market; color = :blue )
        print(  &quot; using &quot;)
        printstyled( micmac ; color = micmac == :micro ? :green : :red )
        println( &quot; data&quot; )
        return z[i,t] * x[j,t]
    end</code></pre><h3 id="Bang-version"><a class="docs-heading-anchor" href="#Bang-version">Bang version</a><a id="Bang-version-1"></a><a class="docs-heading-anchor-permalink" href="#Bang-version" title="Permalink"></a></h3><p>With the bang version, one creates two callback methods, one for the micro interactions and one for the macro interactions.  The difference with the simple version above is that here the user fills an entire array instead of returning a single value.</p><p>Two simple examples that achieve the same thing as if the user-defined interaction callbacks were omitted are shown below.  Remember that the list of product names is only passed in the <code>:micro</code> calls, which is the first callback.</p><p>Note that in the first callback, the last element is omitted for the simple reason that there are no data on the outside good (always the last element) in <code>x</code> during the <code>:micro</code> call.</p><pre><code class="nohighlight hljs">    function InteractionsCallback!( A, z, x, micmac, market, products )  # micro
        for i ∈ axes( A, 1 ), j ∈ 1:size( A, 2 ) - 1, t ∈ axes( A, 3 )
            A[i,j,t] = z[i,t] * x[j,t]
        end
        return nothing
    end

function InteractionsCallback!( A, z, x, θ, micmac, market, products )   # macro
    A .= zero( eltype( A ) )
    for j ∈ axes( A, 2 )
       Threads.@threads :dynamic for i ∈ axes( A, 1 ), 
        for t ∈ axes( z, 2 )
            A[i,j] += z[i,t] * x[j,t] * θ[t]
        end
    end

    return nothing
end</code></pre><p>The main advantage of the bang version is that each method is only called once for each market (for each iteration), not thousands of times.  This reduces overhead when the product identities are used in the construction of interaction terms.</p><h3 id="Most-flexible-version"><a class="docs-heading-anchor" href="#Most-flexible-version">Most flexible version</a><a id="Most-flexible-version-1"></a><a class="docs-heading-anchor-permalink" href="#Most-flexible-version" title="Permalink"></a></h3><p>The most flexible version is also the hardest, so avoid this approach unless the above two approaches are inadequate.</p><p>Pretty much all methods that Grumps uses to create data take an input parameter named <code>id</code>.  This corresponds to the <code>id</code> set in <a href="../objects/#Grumps.DataOptions-Tuple{}"><code>DataOptions()</code></a>, which is <code>:Grumps</code> by default.  This id can be set to any other symbol.  For instance, if one set <code>id</code> to <code>:myid</code> then one could add any of the methods taking an <code>id</code> in any of the Julia code files in <code>src/common/data</code> with one&#39;s own version.  For instance, the following method is defined in <code>micro.jl</code>:</p><pre><code class="nohighlight hljs">    function CreateInteractions( id ::Any, dfc:: AbstractDataFrame, dfp:: AbstractDataFrame, v :: Variables, T = F64 )
        MustBeInDF( v.interactions[:,1], dfc, &quot;consumer data frame&quot; )
        MustBeInDF( v.interactions[:,2], dfp, &quot;product data frame&quot; )

        S = nrow( dfc )
        J = nrow( dfp ) + 1
        dθz = size( v.interactions, 1 )
        Z = zeros( T, S, J, dθz )
        for t ∈ 1:dθz, j ∈ 1:J-1, i ∈ 1:S
            Z[i,j,t] = dfc[i, v.interactions[t,1] ] * dfp[j, v.interactions[t,2] ]
        end
        return Z
    end</code></pre><p>If one now defines a new method in one&#39;s own code with </p><pre><code class="nohighlight hljs">    function Grumps.CreateInteractions( ::Val{ :myid }, dfc, dfp, v, T )
        ...
        ...
        ...
    return Z
end</code></pre><p>then Grumps will call the newly minted method instead of the default one.  But note that one would also need to adjust the corresponding macro integration part for estimators that use both micro and macro likelihoods.  For any functions for which no user-defined methods corresponding to the given <code>id</code> are defined, the default method is called.</p><div class="admonition is-info"><header class="admonition-header">hogs and ants</header><div class="admonition-body"><p>By default, Grumps saves on storage by storing <em>macro</em> draws and regressors separately (:Ant mode for macro).  If one wanted a regressor that could not be expressed as e.g. the product of a demographic variable and a product variable, then the functions <code>FillAθ!</code> and <code>FillZXθ!</code> in <code>src/common/probs/index.jl</code> may need to have new methods added, also, if one wants to continue using :Ant mode.  An alternative for small problems is to switch to :Hog mode for the macro likelihood (the micro likelihood uses :Hog mode by default).</p></div></div><div class="admonition is-warning"><header class="admonition-header">two ids</header><div class="admonition-body"><p>There is one id for data creation passed in <a href="../objects/#Grumps.DataOptions-Tuple{}"><code>DataOptions()</code></a> and one id for the optimization process passed in <a href="../objects/#Grumps.OptimizationOptions-Tuple{}"><code>OptimizationOptions()</code></a>.  These ids <em>can</em> be different, but in most instances it is better to set these to the same value.  Note that the id used in <code>FillAθ!</code> and <code>FillZXθ!</code> is the optimization process id, not the data storage id.</p></div></div><h2 id="Adding-a-new-estimator"><a class="docs-heading-anchor" href="#Adding-a-new-estimator">Adding a new estimator</a><a id="Adding-a-new-estimator-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-new-estimator" title="Permalink"></a></h2><h3 id="Estimator-definitions"><a class="docs-heading-anchor" href="#Estimator-definitions">Estimator definitions</a><a id="Estimator-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Estimator-definitions" title="Permalink"></a></h3><p>A new estimator can be added by creating a new folder in the <a href="../structure/#estimators-folder">estimators folder</a>.  By creating the folder, Grumps will automatically try to load an eponymous Julia file in that folder every time Grumps is run.  For instance, in <code>src/estimators/cler</code> you see a file <code>cler.jl</code>, which loads all Julia files in the folder <em>other than</em> <code>description.jl</code>. The file <code>description.jl</code> is loaded separately and automatically. </p><p>The symbol used for the new estimator will correspond to the folder name.  For instance, if the folder name is <code>foo</code> then the new estimator symbol will be <code>:foo</code>.</p><p>The file <code>description.jl</code> should contain exactly two functions: <code>name</code> and <code>Description</code>.  It suffices to copy the <code>description.jl</code> file from another estimators folder and changing the particulars for your estimator.</p><p>For instance, the <code>cler</code> folder contains the file <code>description.jl</code> with contents</p><pre><code class="nohighlight hljs">name( ::Val{:cler} ) = &quot;Conformant Likelihood with Exogeneity Restrictions&quot;


function Description( e :: Symbol, v ::Val{ :cler } )
    @ensure e == :cler &quot;oops!&quot;
    return EstimatorDescription( e, name( Val( :cler ) ), 
      [ &quot;grumps&quot;, &quot;pmle&quot;, &quot;grumps penalized mle&quot;, &quot;penalized likelihood&quot;, &quot;grumps penalized maximum likelihood&quot;, &quot;pml&quot;, &quot;penmaxlik&quot;, &quot;grumps pml&quot;, &quot;cler&quot;, &quot;full cler&quot; ]
      )
end</code></pre><p>All you need to do here is to change all the <code>:cler</code> entries to <code>:foo</code>, to change the return value of <code>name</code> to <code>&quot;Foo Estimator&quot;</code> and the array of strings in the return value of <code>Description</code> to a list of descriptors of your estimation method that define it clearly and set it apart from other estimators.  Make sure that none of the descriptors are used by other estimators.</p><p>In a file loaded by <code>foo.jl</code>, preferably <code>types.jl</code>, one should define some properties of the estimators. In addition, there is a type associated with your estimator. For instance, the file <code>types.jl</code> in the <code>cler</code> folder contains</p><pre><code class="nohighlight hljs">struct GrumpsCLEREstimator &lt;: GrumpsPenalized
    function GrumpsCLEREstimator() 
        new()
    end
end

name( ::GrumpsCLEREstimator ) = name( Val( :cler ) )

inisout( ::GrumpsCLEREstimator ) = true

Estimator( ::Val{ :cler } ) = GrumpsCLEREstimator()</code></pre><p>The estimator type <code>GrumpsCLEREstimator</code> is used to allow Grumps to use the same function name with the estimator type to call different methods.  Note that <code>GrumpsCLEREstimator</code> is a subtype of <code>GrumpsPenalized</code>, which is done to allow for a single function call with different estimator type argument to select a method for all estimators that are subtypes of <code>GrumpsPenalized</code>.</p><p>For example, if one calls a function with an estimator type (and other arguments) then there is a default method that will be called unless there is a method defined for the desired supertype (e.g. <code>GrumpsPenalized</code>), which will be called unless there is a method defined for the exact estimator type (e.g. <code>GrumpsCLEREstimator</code>).</p><p>For instance, the outer objective functions are all called <code>ObjectiveFunctionθ!</code> but which one is used depends on the estimator supertype.  For <code>GrumpsPenalized</code> it is the one in <code>src/common/optim/objpml.jl</code>.  Note that you can define different objective functions depending on e.g. the <code>GrumpsData</code> type that is passed, also.</p><p>For the new estimator <code>:foo</code> the <code>name</code> and <code>Estimator</code> methods in the above file can be changed by replacing <code>:cler</code> with <code>:foo</code> and <code>CLER</code> with <code>Foo</code> everywhere, assuming that the new estimator type is <code>GrumpsFooEstimator</code>.</p><p>The final entry in <code>types.jl</code> is the line  <code>inisout( ::GrumpsCLEREstimator ) = true</code> What this line does is to tell Grumps that the value of the likelihood component of the objective function in the inner optimization problem is the same as that in the outer optimization problem.  This is true for most estimators, but not for e.g. the share constraint estimator.  There are a number of properties like this (type <code>Estimators(true)</code> in the REPL to see them all), whose default values are in <code>src/common/types/est.jl</code>.</p><p>Now, the <code>:mdle</code> (the Grumps estimator with exact identification in the product level moments) and <code>:shareconstraint</code> (ditto, but where the inner optimization runs maximizes only the macro likelihood) computations differ only in the contents of the <code>theta.jl</code> and <code>delta.jl</code> files.  In this case, the <code>theta.jl</code> files produce the single market outer objective function contributions and its first two derivatives and <code>delta.j</code> does ditto for the inner objective functions.</p><h3 id="Data-types"><a class="docs-heading-anchor" href="#Data-types">Data types</a><a id="Data-types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-types" title="Permalink"></a></h3><p>There are several predefined <code>Data</code> types, which can be found in <code>src/common/types/data.jl</code>.  For instance, <code>GrumpsData</code> contains a vector of <code>GrumpsMarketData</code> objects (one for each market), a <code>GrumpsPLMData</code> object, and some other things.  <code>GrumpsPLMData</code> is for the penalty term.</p><p>Each <code>GrumpsMarketData</code> object contains a <code>GrumpsMicroData</code> object and a <code>GrumpsMacroData</code> object, one for the micro portion of the likelihood, and one for the macro portion of the likelihood.  These are themselves supertypes, so you can use/require whichever subtype you desire for your estimator, but if one of the existing ones suffices then use that.</p><h3 id="FGH-types"><a class="docs-heading-anchor" href="#FGH-types">FGH types</a><a id="FGH-types-1"></a><a class="docs-heading-anchor-permalink" href="#FGH-types" title="Permalink"></a></h3><p>FGH types contain the objective function and its derivatives.  These can be by market or apply to (or contain results for) a number of markets.  If <code>inisout</code> returns <code>true</code> then the inner and outer objective <code>FGH</code> objects are physically the same.</p><h3 id="Space-types"><a class="docs-heading-anchor" href="#Space-types">Space types</a><a id="Space-types-1"></a><a class="docs-heading-anchor-permalink" href="#Space-types" title="Permalink"></a></h3><p>Grumps preallocates space for choice probabilities and related objects and reuses their values where possible.  This saves computation time.  In most instances, the space types provided will suffice.</p><h2 id="Adding-an-integrator"><a class="docs-heading-anchor" href="#Adding-an-integrator">Adding an integrator</a><a id="Adding-an-integrator-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-an-integrator" title="Permalink"></a></h2><p>The default integrators used by Grumps (see <a href="../objects/#Grumps.DefaultMicroIntegrator-Tuple{Int64, Type}"><code>DefaultMicroIntegrator( ::Int, ::Type )</code></a> and <a href="../objects/#Grumps.DefaultMacroIntegrator-Tuple{Int64, Type}"><code>DefaultMacroIntegrator( ::Int, ::Type )</code></a>) are limited in their functionality.  It is possible to define a new integrator. </p><div class="admonition is-warning"><header class="admonition-header">Adding integrators is untested</header><div class="admonition-body"><p>Proceed with caution, ask for help if stuck.</p></div></div><p>The way to accomplish this is to create a new folder in <code>src/integrators</code> and create a Julia file with the same name in that folder.  For instance, the folder could be called <code>myintegrator</code> and the file in that folder <code>myintegrator.jl</code>.</p><p>There are two types of integrators.  The example below will be for a micro integrator: the procedure for adding a macro integrator is similar.</p><p>Consider the definition of the <code>DefaultMicroIntegrator</code> in <code>src/common/types/nodesweights.jl</code>:</p><pre><code class="nohighlight hljs">    struct DefaultMicroIntegrator{T&lt;:Flt} &lt;: MicroIntegrator{T}   
        n   :: Int
    end</code></pre><p>This defines a MicroIntegrator called <code>DefaultMicroIntegrator</code> that uses a single integer-valued parameter <code>n</code> and can handle arbitrary floating point numbers (<code>Flt</code> is shorthand for <code>AbstractFloat</code>).  We need to define a constructor for that, which is defined in the same file, namely:</p><pre><code class="nohighlight hljs">function DefaultMicroIntegrator( n :: Int, T = F64; options = nothing )
    @ensure n &gt; 0  &quot;n must be positive&quot;
    DefaultMicroIntegrator{T}( n )
end</code></pre><p>This is how one creates a variable of type <code>DefaultMicroIntegrator</code>.  This constructor requires <code>n</code> to be specified, takes <code>Float64</code> as the default floating point type, and does not use any further options.  The <code>options</code> argument is there in case one wants to define additional inputs to the integrator.</p><p>For every integrator, one should define two methods: <code>NodesWeightsGlobal</code> and <code>NodesWeightsOneMarket</code>.  For the <code>DefaultMicroIntegrator</code> the method <code>NodesWeightsGlobal</code> is lengthy and its contents below are omitted.  Its <code>NodesWeightsOneMarket</code> method is very short and it is displayed in its entirety.  The full method definitions can be found in <code>src/common/integration/micro.jl</code>.</p><pre><code class="nohighlight hljs">function NodesWeightsGlobal( ms :: DefaultMicroIntegrator{T}, d :: Int,  rng :: AbstractRNG ) where {T&lt;:Flt}
    ( lengthy content omitted )
  return GrumpsNodesWeights{T}(n, w)
end

function NodesWeightsOneMarket( ms :: DefaultMicroIntegrator{T}, d :: Int, rng :: AbstractRNG, nwgmic :: GrumpsNodesWeights{T}, S :: Int ) where {T&lt;:Flt}
   return nwgmic
end</code></pre><p>The reason that there is both a global method and a method for a single market is that for some integrators (like <code>DefaultMicroIntegrator</code>) the nodes and weights are the same for each market so only have to be generated once in <code>NodesWeightsGlobal</code> and can then simply be reused for every market.  This is why <code>NodesWeightsOneMarket</code> for <code>DefaultMicroIntegrator</code> simply returns its <code>nwgmic</code> argument: those are simply the nodes and weights generated in <code>NodesWeightsGlobal</code>.</p><p>For the <code>DefaultMacroIntegrator</code> the converse is true: <code>NodesWeightsGlobal</code> does nothing and <code>NodesWeightsOneMarket</code> does all the work.  These methods can be found in <code>src/common/integration/macro.jl</code>, where it should be noted that the prototypes for macro integrators differ from those for micro integrators.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bearinmind/">« Things to bear in mind</a><a class="docs-footer-nextpage" href="../aliens/">Languages other than Julia »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 11 March 2025 19:14">Tuesday 11 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
