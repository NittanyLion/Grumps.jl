<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User interface · Grumps.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Grumps.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../estimators/">Estimators</a></li><li><a class="tocitem" href="../quickstart/">Quick start</a></li><li class="is-active"><a class="tocitem" href>User interface</a><ul class="internal"><li><a class="tocitem" href="#Data-entry"><span>Data entry</span></a></li><li><a class="tocitem" href="#Optimization-options"><span>Optimization options</span></a></li><li><a class="tocitem" href="#Data-storage-options"><span>Data storage options</span></a></li><li><a class="tocitem" href="#Standard-error-options"><span>Standard error options</span></a></li><li><a class="tocitem" href="#Estimator-choice"><span>Estimator choice</span></a></li><li><a class="tocitem" href="#Choice-of-integration-method-(integrators)"><span>Choice of integration method (integrators)</span></a></li><li><a class="tocitem" href="#Data-object-creation"><span>Data object creation</span></a></li><li><a class="tocitem" href="#Algorithm-call"><span>Algorithm call</span></a></li><li><a class="tocitem" href="#Retrieving-results"><span>Retrieving results</span></a></li><li><a class="tocitem" href="#Memory-conservation"><span>Memory conservation</span></a></li></ul></li><li><a class="tocitem" href="../spreadsheet/">Spreadsheet formats</a></li><li><a class="tocitem" href="../example/">Example program</a></li><li><a class="tocitem" href="../bearinmind/">Things to bear in mind</a></li><li><a class="tocitem" href="../structure/">Directory structure</a></li><li><a class="tocitem" href="../flow/">Algorithm flow</a></li><li><a class="tocitem" href="../extending/">Extending Grumps</a></li><li><a class="tocitem" href="../aliens/">Languages other than Julia</a></li><li><a class="tocitem" href="../misc/">Miscellanea</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NittanyLion/Grumps.jl/blob/master/docs/src/objects.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="User-Interface"><a class="docs-heading-anchor" href="#User-Interface">User Interface</a><a id="User-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#User-Interface" title="Permalink"></a></h1><p>The sections below describe the main calls needed to use Grumps.  For any functions that are not documented here, simply use ? in the REPL, e.g. ?Variables.</p><p>The way that Grumps works is that one first specifies where the data are stored, what specification to use, which estimator to use, etcetera, before calling the functions that actually perform work with these choices.  All sections below up to and including the choice of integration method specify things, data object creation and algorithm call create and compute things, and the remainder deals with the retrieval of estimation results and memory conservation.</p><h2 id="Data-entry"><a class="docs-heading-anchor" href="#Data-entry">Data entry</a><a id="Data-entry-1"></a><a class="docs-heading-anchor-permalink" href="#Data-entry" title="Permalink"></a></h2><p>The methods below are used to enter data into Grumps.  With <a href="#Grumps.Sources-Tuple{}"><code>Sources()</code></a> one specifies where the data can be found and with <a href="#Grumps.Variables-Tuple{}"><code>Variables()</code></a> which variables to use from those data sources.  Note that there are two versions of the <em>Variables</em> method, where the main difference is the syntax.  Use whichever one you prefer.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.Sources-Tuple{}" href="#Grumps.Sources-Tuple{}"><code>Grumps.Sources</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Sources( 
    T           = DefaultSourceTypes; 
    consumers   :: Any = nothing, 
    products    :: Any = nothing, 
    marketsizes :: Any = nothing, 
    draws       :: Any = nothing,
    user        :: Any = nothing
)</code></pre><p>Creates a GrumpsSources object with source type entries of type T where the entries are provided in the optional parameters.</p><p>Grumps (potentially) uses four data sources: a data source for consumer-level data, one for product-level data, one for market size information, and one for demographic draws.  Only the product-level data are required, but are by themselves insufficient.  For instance, for BLP95 one needs information on products, market sizes, and demographics; for the Grumps estimator one needs all four types of data; for a multinomial logit both consumer and product information are needed.  Not all data are needed for all markets.  For instance, it is ok for some estimators for there to be consumer-level data in some markets but not others.</p><p>The T argument is mostly there to allow for future expansion, so the description below applies to the case in which T = DefaultSourceTypes.</p><p>By default, the entries can be nothing, a string, a DataFrame, or a SourceFileType.  If an entry is nothing, it means that no such data is to be used.  If an entry is a string then it is converted to a SourceFileCSV entry with comma delimiter where the string name is the file name.  To use other source file types, create a SourceFileType first.  A DataFrame can be passed, also.  In all cases other than nothing, data will eventually be (converted to) a DataFrame and parsed from that.</p><p>The <em>consumers</em> variable specifies where consumer-level data can be found, the <em>products</em> variable is for the product-level data, <em>marketsizes</em> is for market sizes, and <em>draws</em> is for demographic draws; <em>user</em> has not been implemented yet.</p><p>Use the <a href="#Grumps.Variables-Tuple{}"><code>Variables()</code></a> method to specify the way the data sources are formatted and the specification to estimate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/source.jl#L35-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Variables-Tuple{}" href="#Grumps.Variables-Tuple{}"><code>Grumps.Variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Variables( ; 
  market              :: Symbol = :market,
  choice              :: Symbol = :choice,
  interactions        :: Mat{Symbol} = [],
  randomcoefficients  :: Vec{Symbol} = [],
  outsidegood         :: String = &quot;outsidegood&quot;,
  share               :: Symbol = :share,
  marketsize          :: Symbol = :N,
  regressors          :: Vec{Symbol} = [],
  instruments         :: Vec{Symbol} = [],
  dummies             :: Vec{Symbol} = [],
  nuisancedummy       :: Symbol = :none,
  microinstruments    :: Mat{Symbol} = [],
  user                :: Mat{Symbol} = []
    )</code></pre><p>This method is used to specify regressors, instruments, random coefficients, interactions, variable labels, etcetera, from the sources you have specified in <a href="#Grumps.Sources-Tuple{}"><code>Sources()</code></a>. It creates an object of type <em>GrumpsVariables</em>.</p><p>For instance, the option <em>market</em> specifies the column heading of the column containing the market descriptor (name).  The same is true for all other arguments, except <em>outsidegood</em> which describes the spreadsheet entry that indicates the product is an outside good.  The  same label for the outside good should be used in all spreadsheets and all markets. Outside good entries  should only be used in the consumer micro data and then only if there actually are consumers in the micro data choosing the outside good. All descriptors are case and space sensitive.</p><p>There is a separation between variables that go into the individual consumer utility and ones that only go into &quot;mean utility&quot;.  For instance, <em>interactions</em> tells Grumps which interaction terms to use and <em>randomcoefficients</em> which product level regressors are hit with a random coefficient.  By contrast, <em>regressors</em> go into the mean utility component and are regressors in the &quot;second stage&quot; (where β is recovered). One can use the special symbol <em>:constant</em> to indicate a constant is to be used; the spreadsheet need not include a column with that heading.</p><p>Note that there are three ways that dummy variables can be entered as second stage regressors.  The first is via <em>regressors</em>, in which case the onus is on the user to ensure that they have the correct numerical values.  The second possibility is via the <em>dummies</em> argument.  For  each symbol passed via the <em>dummies</em> argument, Grumps will examine the corresponding column of the product data set (which can contain descriptive entries that need not be numerical) and turn it into dummy variables.  If the coefficient on the dummies is of no interest then it is better to pass one via the <em>nuisancedummy</em> argument since it saves both computation time and memory.  There can only be at most one categorical variable that can be converted to nuisance dummies, but there can be arbitrarily many categories.  These dummies and nuisance dummies are automatically assumed to be exogenous and will be included in the instruments, also.</p><p><em>market</em> refers to the variable containing the market indicator in all input datasets.  Strings work best for the market indicators themselves, but it is not a requirement.</p><p><em>product</em> refers to the variable containing the product indicator in the product dataset. Strings work best for the product indicators themselves, but it is not a requirement.</p><p><em>choice</em> refers to the variable indicating the choice indicator in the consumer level datasets.  Strings work best for the choice indicators themselves, but it is not a requirement.</p><p><em>interactions</em> refers to the variables indicating consumer and product variable interactions (each row contains consumer variable, product variable)</p><p><em>randomcoefficients</em> refers to the product level variables that have a random coefficient on them</p><p><em>outsidegood</em> refers to the label used for the outside good</p><p><em>share</em> refers to the label used for the product level share; these are shares where the denominator includes the outside good</p><p><em>marketsize</em> refers to the size of the market (number of people)</p><p><em>regressors</em> refers to the label used for the second stage regressors</p><p><em>instruments</em> refers to the label used for the second stage instruments</p><p><em>dummies</em> refers to discrete variables to be converted to second stage dummy regressors and instruments</p><p><em>nuisancedummy</em> refers to at most one variable to be converted to a second stage dummy regressors and instrument whose coefficient value is of no interest</p><p><em>microinstruments</em> refers to micro instruments, which are only relevant for gmm style procedures</p><p><em>user</em> refers to a list of variables to be added to the consumer-product interactions using a user-specified procedure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/variables.jl#L50-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Variables-NTuple{4, String}" href="#Grumps.Variables-NTuple{4, String}"><code>Grumps.Variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Variables( 
    microspec           :: String,
    macrospec           :: String,
    dummyspec           :: String = &quot;&quot;,
    nuisancedummyspec   :: String = &quot;&quot;;
    market              :: String = &quot;market&quot;,
    product             :: String = &quot;product&quot;,
    outsidegood         :: String = &quot;outsidegood&quot;,
    marketsize          :: String = &quot;N&quot;,
    microinstruments    :: String = &quot;&quot;,
    user                :: String = &quot;&quot;
    )</code></pre><p>This method is used to specify regressors, instruments, random coefficients, interactions, variable labels, etcetera, from the sources you have specified in <a href="#Grumps.Sources-Tuple{}"><code>Sources()</code></a>. It creates an object of type <em>GrumpsVariables</em>.  There is another method by the same name that accomplishes much the same thing, but has a different user interface. </p><p>The method described here takes string arguments, including two mandatory ones, whereas the other method takes optional arguments only, mostly symbols, vectors of symbols, and matrices of symbols that can be passed in arbitrary order using keywords.  The current method parses user input before calling the other method.</p><p>The option <em>market</em> specifies the column heading of the column containing the market descriptor (name).  The same is true for all other  arguments, except <em>outsidegood</em> which describes the spreadsheet entry that indicates the product is an outside good.  The same label for  the outside good should be used in all spreadsheets and all markets. Outside good entries should only be used in the consumer micro data  and then only if there actually are consumers in the micro data choosing the outside good. All descriptors are case sensitive.</p><p>There is a separation between variables that go into the individual consumer utility and ones that only go into &quot;mean utility&quot;.  For instance, to specify what goes into individual consumer utility, one could specify</p><p>&quot;choice = loginc * msrp + famsize * logfootprint + famsize * van + urban * truck + rc * suv + rc * truck + rc * van&quot;</p><p>as the <em>microspec</em> argument to indicate that consumer choice is in the micro data set in a column headed &quot;choice&quot; and that there are four interaction terms and three random coefficients.  The interaction terms have the consumer-level variable as the first factor and the product  variable as the second argument.  In this example the three random coefficients are on the suv, truck, and van variables and these variable names should correspond to the column headings in the product level data set.  One can use <em>constant</em> to indicate a constant is used: there is no need to include a constant in one&#39;s data.</p><p>The <em>macrospec</em> argument takes the form </p><p>&quot;share = constant + logmpg + loghp + logfootprint + msrp / constant, logmpg, loghp, logfootprint, logcurbweight, lagplcon&quot;</p><p>where <em>share</em> are product-level market shares, everything between = and / represents regressors, and everything after / represents  instruments; both regressors and instruments are for the product level moments portion.  One can again use <em>constant</em> to indicate a constant is used, which need not be included in one&#39;s data.</p><p>Note that there are three ways that dummy variables can be entered as second stage regressors.  The first is via <em>macrospec</em>, in which case the onus is on the user to ensure that they have the correct numerical values.  The second possibility is via the <em>dummyspec</em> argument.  For  each variable passed via the <em>dummyspec</em> argument, Grumps will examine the corresponding column of the product data set (which can contain descriptive entries that need not be numerical) and turn it into dummy variables.  If the coefficient on the dummies is of no interest then it is better to pass one via the <em>nuisancedummyspec</em> argument since it saves both computation time and memory.  There can only be at most one categorical variable that can be converted to nuisance dummies, but there can be arbitrarily many categories.  These dummies and nuisance dummies are automatically assumed to be exogenous and will be included in the instruments, also.</p><p><em>market</em> refers to the variable containing the market indicator in all input datasets.  Strings work best for the market indicators themselves, but it is not a requirement.</p><p><em>product</em> refers to the variable containing the product indicator in the product dataset. Strings work best for the product indicators themselves, but it is not a requirement.</p><p><em>choice</em> refers to the variable indicating the choice indicator in the consumer level datasets.  Strings work best for the choice indicators themselves, but it is not a requirement.</p><p><em>interactions</em> refers to the variables indicating consumer and product variable interactions (each row contains consumer variable, product variable)</p><p><em>randomcoefficients</em> refers to the product level variables that have a random coefficient on them</p><p><em>outsidegood</em> refers to the label used for the outside good</p><p><em>share</em> refers to the label used for the product level share; these are shares where the denominator includes the outside good</p><p><em>marketsize</em> refers to the size of the market (number of people)</p><p><em>regressors</em> refers to the label used for the second stage regressors</p><p><em>instruments</em> refers to the label used for the second stage instruments</p><p><em>dummies</em> refers to discrete variables to be converted to second stage dummy regressors and instruments</p><p><em>nuisancedummy</em> refers to at most one variable to be converted to a second stage dummy regressors and instrument whose coefficient value is of no interest</p><p><em>microinstruments</em> refers to micro instruments, which are only relevant for gmm style procedures</p><p><em>user</em> refers to a list of variables to be added to the consumer-product interactions using a user-specified procedure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/variables.jl#L188-L272">source</a></section></article><h2 id="Optimization-options"><a class="docs-heading-anchor" href="#Optimization-options">Optimization options</a><a id="Optimization-options-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-options" title="Permalink"></a></h2><p>The default optimization options are sensible, in which case this section can be skipped.  But for those who want to play with tolerances and such, have at it.</p><p>There is one exception, however, and that exception pertains to using less memory.  There is a separate section dedicated to that possibility, namely <a href="#Memory-conservation">Memory conservation</a></p><article class="docstring"><header><a class="docstring-binding" id="Grumps.OptimizationOptions-Tuple{}" href="#Grumps.OptimizationOptions-Tuple{}"><code>Grumps.OptimizationOptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OptimizationOptions(; 
θopt = OptimOptionsθ(), 
δopt = OptimOptionsδ(), 
threads = GrumpsThreads(), 
memsave = false, 
maxrepeats = 4, 
probtype = :fast )</code></pre><p>Sets the options used for numerical optimization.  <em>θopt</em> is used for the external optimization routine, <em>δopt</em> for the internal one.  These are both of type <em>OptimOptions</em>; see the <em>OptimOptionsθ</em> and <em>OptimOptionsδ</em> methods for elaboration.  The <em>memsave</em> variable is set to false by default; turning it on will reduce memory consumption significantly, but will also slow down computation.  The variable <em>maxrepeats</em> may disappear in the  future.  </p><p>Finally, there are two ways of computing choice probabilities: robust and fast, specified by passing <em>:robust</em> or <em>:fast</em> in <em>probtype</em>. Fast choice probabilities are the default for good reason.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/options.jl#L186-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.OptimOptionsθ-Tuple{}" href="#Grumps.OptimOptionsθ-Tuple{}"><code>Grumps.OptimOptionsθ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OptimOptionsθ(; 
f_tol = 1.0e-8, 
g_tol = 1.0e-4, 
x_tol = 1.0e-5, 
iterations = 25, 
show_trace = true, 
store_trace = true, 
extended_trace = true )</code></pre><p>Creates and returns an <em>OptimOptions</em> optimization options variable for the outer optimization algorithm, including the function value tolerance, the gradient tolerance, the solution tolerance, the maximum number of iterations, whether to show the trace, whether to store the trace, and whether to keep the extended trace.  See the <strong>Optim</strong> package for details.  </p><p>The current version of Grumps will largely ignore the trace-related parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/options.jl#L75-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.OptimOptionsδ-Tuple{}" href="#Grumps.OptimOptionsδ-Tuple{}"><code>Grumps.OptimOptionsδ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OptimOptionsδ( ; 
f_tol = 1.0e-8, 
g_tol = 1.0e-8, 
x_tol = 1.0e-6, 
iterations = 25, 
show_trace = false, 
store_trace = true, 
extended_trace = false )</code></pre><p>Creates and returns an <em>OptimOptions</em> optimization options variable for the inner optimization algorithm, including the function value tolerance, the gradient tolerance, the solution tolerance, the maximum number of iterations, whether to show the trace, whether to store the trace, and whether to keep the extended trace.  See the <strong>Optim</strong> package for details.  </p><p>The current version of Grumps will largely ignore the trace-related parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/options.jl#L95-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.GrumpsThreads-Tuple{}" href="#Grumps.GrumpsThreads-Tuple{}"><code>Grumps.GrumpsThreads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GrumpsThreads(; 
    blas = 0, 
    markets = 0, 
    inner = 0 
    )</code></pre><p>This sets the number of threads to be used subject to a number of caveats.  <em>blas</em> refers to the number of BLAS threads, <em>markets</em> to the number of threads in loops over markets, and <em>inner</em> to the number of threads in inner loops.  A value of zero forces the automatic selection of the number of threads.</p><p>Of these, <em>inner</em> is not currently used at all, <em>market</em> is only used in <em>memsave</em> mode, and <em>blas</em> is used.  However, please note that the number of threads used by Grumps altogether is the number of threads passed in via the command line argument (i.e. via the -t switch), where that number does not include the number of BLAS threads set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/options.jl#L127-L140">source</a></section></article><h2 id="Data-storage-options"><a class="docs-heading-anchor" href="#Data-storage-options">Data storage options</a><a id="Data-storage-options-1"></a><a class="docs-heading-anchor-permalink" href="#Data-storage-options" title="Permalink"></a></h2><p>The default data storage options are sensible, but some space can be saved by tinkering with the settings.  However, the only parameter that is worth changing is σ2, which is the variance of ξ, the product level error term.  This is of no relevance for two-stage estimators like unpenalized mle.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.DataOptions-Tuple{}" href="#Grumps.DataOptions-Tuple{}"><code>Grumps.DataOptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataOptions(; 
    micromode   = :Hog
    macromode   = :Ant
    balance     = :micro
    σ2          = 1.0
)</code></pre><p>Specifies how Grumps should store its data and what it should store.  The first three options are best left alone, unless you know what it is you&#39;re doing.  The last option is the variance of ξ, i.e. the error variance in the product level moments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/options.jl#L23-L33">source</a></section></article><h2 id="Standard-error-options"><a class="docs-heading-anchor" href="#Standard-error-options">Standard error options</a><a id="Standard-error-options-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-error-options" title="Permalink"></a></h2><p><strong>stub</strong></p><article class="docstring"><header><a class="docstring-binding" id="Grumps.StandardErrorOptions-Tuple{}" href="#Grumps.StandardErrorOptions-Tuple{}"><code>Grumps.StandardErrorOptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StandardErrorOptions(; θ = true, δ = true, β = true, setype = :homo )</code></pre><p>Specifies which coefficients to create standard errors for and what type of standard errors to produce.  Current choices are :homo (i.e. assuming homoskedasticity) and :hetero (heteroskedasticity-robust).  Fancier options will be added at a future point in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/options.jl#L221-L225">source</a></section></article><h2 id="Estimator-choice"><a class="docs-heading-anchor" href="#Estimator-choice">Estimator choice</a><a id="Estimator-choice-1"></a><a class="docs-heading-anchor-permalink" href="#Estimator-choice" title="Permalink"></a></h2><p>Grumps can compute quite a few estimators and one can specify which estimator to use by passing the return value of a call to <code>Estimator</code> to the optimization routine.</p><p>The easiest way to call <code>Estimator</code> is by passing it a string that describes what it is that you want to do.  The following estimators are currently defined:</p><ul><li>the full Grumps estimator</li><li>a less expensive alternative estimator with the same limit distribution as the full Grumps estimator</li><li>Grumps-style maximum likelihood, i.e Grumps without penalty</li><li>ditto, but imposing share constraints</li><li>GMM estimator that uses both micro and macro moments and uses quadrature instead of Monte Carlo draws in the micro moments.  The micro moments are smart in that they condition on <span>$z_{im}$</span> instead of integrating it out.</li><li>a mixed logit estimator</li></ul><p>For a description of these estimators, see <a href="@ref">Estimator</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.Estimator-Tuple{String}" href="#Grumps.Estimator-Tuple{String}"><code>Grumps.Estimator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Estimator( s :: String )</code></pre><p>Creates and returns a GrumpsEstimator type.  Grumps is reasonably good at figuring out what it is that you want, so e.g. <em>Estimator( &quot;maximum likelihood&quot; )</em> gives you the unpenalized Grumps maximum likelihood estimator.</p><p>The estimators currently programmed include:</p><ul><li>the full Grumps estimator</li><li>Grumps-style maximum likelihood, i.e Grumps without penalty</li><li>ditto, but imposing share constraints</li><li>GMM estimator that uses both micro and macro moments and uses quadrature instead of Monte Carlo draws in the micro moments.  The micro moments are `smart&#39; in that they condition on <span>$z_{im}$</span> instead of integrating it out.</li><li>a mixed logit estimator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/est/est.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Estimator-Tuple{Symbol}" href="#Grumps.Estimator-Tuple{Symbol}"><code>Grumps.Estimator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Estimator( s :: Symbol )</code></pre><p>Creates and returns a GrumpsEstimator type.</p><p>This is one method of specifying the estimator used.  However, it is unforgiving in that the exact symbol used internally must be passed, so the <em>Estimator( s :: String )</em> method is usually a better choice.</p><p>Possible choices include:</p><p><em>:pml</em> the full Grumps maximum likelihood estimator  </p><p><em>:vanilla</em> the unpenalized Grumps maximum likelihood estimator</p><p><em>:shareconstraint</em> the unpenalized Grumps maximum likelihood estimator with share constraints</p><p><em>:gmm</em> GMM estimator that uses both micro and macro moments</p><p><em>:mixedlogit</em> mixed logit maximum likelihood estimator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/est/est.jl#L32-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Estimators-Tuple{}" href="#Grumps.Estimators-Tuple{}"><code>Grumps.Estimators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Estimators( elaborate = false )</code></pre><p>Prints a list of available estimators.  The argument indicates whether a lot of features should be printed  or few.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/est/est.jl#L82-L87">source</a></section></article><h2 id="Choice-of-integration-method-(integrators)"><a class="docs-heading-anchor" href="#Choice-of-integration-method-(integrators)">Choice of integration method (integrators)</a><a id="Choice-of-integration-method-(integrators)-1"></a><a class="docs-heading-anchor-permalink" href="#Choice-of-integration-method-(integrators)" title="Permalink"></a></h2><p>Grumps uses separate integration methods for the micro and macro components. The default choices are simple with small numbers of nodes and draws. For micro, it is Hermitian quadrature, for macro it&#39;s Monte Carlo draws. One gets the defaults if the choices are omitted.  The defaults chosen here are small in the sense that they emphasize speed / storage over accuracy.   To change the number of nodes or draws, simply call BothIntegrators with as argument(s), whichever of the two you wish to change.  For instance, <code>integ = BothIntegrators( DefaultMicroIntegrator( 19 ) )</code> uses the default micro integrator with 19 nodes per dimension and the default macro integrator with the default number of draws.</p><p>The procedure is to create the integrators using a call to BothIntegrators with the desired integrators as arguments and then pass this in your call to <code>Data</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.BothIntegrators-Union{Tuple{T}, Tuple{MicroIntegrator{T}, MacroIntegrator{T}}} where T&lt;:AbstractFloat" href="#Grumps.BothIntegrators-Union{Tuple{T}, Tuple{MicroIntegrator{T}, MacroIntegrator{T}}} where T&lt;:AbstractFloat"><code>Grumps.BothIntegrators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BothIntegrators( microIntegrator :: MicroIntegrator{T}, macroIntegrator :: MacroIntegrator{T} )</code></pre><p>Creates the type BothIntegrators containing both the indicated microIntegrator and macroIntegrator.  </p><p>Either argument can be omitted.  If both arguments are omitted then one can pass the floating point type T instead.  If no floating point type is passed then a Float64 is assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/nodesweights.jl#L126-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.DefaultMicroIntegrator-Tuple{Int64, Type}" href="#Grumps.DefaultMicroIntegrator-Tuple{Int64, Type}"><code>Grumps.DefaultMicroIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DefaultMicroIntegrator( n :: Int, T :: Type )</code></pre><p>Creates a basic quadrature Integrator using n nodes in each dimension.  Type T can be omitted, in which case it is Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/nodesweights.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.DefaultMacroIntegrator-Tuple{Int64, Type}" href="#Grumps.DefaultMacroIntegrator-Tuple{Int64, Type}"><code>Grumps.DefaultMacroIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DefaultMacroIntegrator( n :: Int, T :: Type )</code></pre><p>Creates a basic Monte Carlo Integrator using n draws.  Type T can be omitted, in which case it is Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/nodesweights.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.MSMMicroIntegrator-Tuple{Int64, Type}" href="#Grumps.MSMMicroIntegrator-Tuple{Int64, Type}"><code>Grumps.MSMMicroIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MSMMicroIntegrator( n :: Int, T = F64 )</code></pre><p>Creates a Monte Carlo integrator type for <em>micro</em> integration with GMM with smart moments.  The optional type can be omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/nodesweights.jl#L72-L76">source</a></section></article><h2 id="Data-object-creation"><a class="docs-heading-anchor" href="#Data-object-creation">Data object creation</a><a id="Data-object-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-object-creation" title="Permalink"></a></h2><p>The data stored in spreadsheets or other objects have to be converted into a form that Grumps understands.  The call to <code>Data</code> achieves that.   It takes as inputs the various choices made by the user and then creates an appropriate data object that is subsequently passed to the optimization call.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.Data-Tuple{}" href="#Grumps.Data-Tuple{}"><code>Grumps.Data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data( 
    e                   :: GrumpsEstimator,
    ss                  :: Sources,
    v                   :: Variables,
    integrators         :: GrumpsIntegrators = BothIntegrators(),
    T                   :: Type = F64,
    u                   :: UserEnhancement = DefaultUserEnhancement();
    options             :: DataOptions = GrumpsDataOptions(),
    threads             :: Int = 0
    )</code></pre><p>Takes user inputs and converts them into an object that Grumps can understand.  This is synonymous with GrumpsData(...).</p><p><em>Data</em> takes the following arguments, of which the first three are mandatory:</p><ul><li><em>e</em>:                   estimator; see <em>Estimator</em></li><li><em>ss</em>:                  cata sources; see <em>Sources</em></li><li><em>v</em>:                   variables to be used; see <em>Variables</em></li><li><em>o</em>:                   optimization options to be used   </li><li><em>integrators</em>:         see <em>BothIntegrators</em>, <em>DefaultMicroIntegrator</em>, and <em>DefaultMacroIntegrator</em></li><li><em>T</em>:                   floating point type; not heavily tested</li><li><em>u</em>:                   not yet implemented</li><li><em>options</em>:             data options to be used, see <em>DataOptions</em></li><li><em>threads</em>:             the number of parallel threads to be used in creating data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/data/all.jl#L154-L179">source</a></section></article><h2 id="Algorithm-call"><a class="docs-heading-anchor" href="#Algorithm-call">Algorithm call</a><a id="Algorithm-call-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-call" title="Permalink"></a></h2><p>Once all data structures have been put together, one can call the algorithm.  This is straightforward.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.grumps!-Union{Tuple{T}, Tuple{Estimator, Data{T}, OptimizationOptions, Union{Nothing, Vector{T}}, StandardErrorOptions}} where T&lt;:AbstractFloat" href="#Grumps.grumps!-Union{Tuple{T}, Tuple{Estimator, Data{T}, OptimizationOptions, Union{Nothing, Vector{T}}, StandardErrorOptions}} where T&lt;:AbstractFloat"><code>Grumps.grumps!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grumps!( 
    e       :: Estimator,
    d       :: Data{T},
    o       :: OptimizationOptions = OptimizationOptions(),
    θstart  :: StartingVector{T} = nothing,
    seo     :: StandardErrorOptions = StandardErrorOptions()
)</code></pre><p>Conducts the optimization.  You typically just want to set θstart to nothing, i.e. have a starting vector  picked automatically.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/optim/est.jl#L8-L19">source</a></section></article><h2 id="Retrieving-results"><a class="docs-heading-anchor" href="#Retrieving-results">Retrieving results</a><a id="Retrieving-results-1"></a><a class="docs-heading-anchor-permalink" href="#Retrieving-results" title="Permalink"></a></h2><p>As noted above, Grumps will return its results in a <code>GrumpsSolution</code> variable that can be queried or saved as follows.  You can also simply call one of the <code>print</code> or  related functions on any of these objects.</p><p>Finally, you can call any of <code>minimum</code>, <code>iterations</code>, <code>iteration_limit_reached</code>, <code>converged</code>, <code>f_converged</code>, <code>g_converged</code>, <code>x_converged</code>, <code>f_calls</code>, <code>g_calls</code>, <code>h_calls</code>, <code>f_trace</code>, <code>g_norm_trace</code>, <code>x_trace</code> on a <code>GrumpsSolution</code> or a <code>GrumpsConvergence</code> object in the same way that you would query the return value in the <a href="https://github.com/JuliaNLSolvers/Optim.jl/">Optim package</a>, albeit that they are not in the namespace by default so use <code>Grumps.converged</code> instead of <code>converged</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.getθ-Tuple{GrumpsSolution}" href="#Grumps.getθ-Tuple{GrumpsSolution}"><code>Grumps.getθ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getθ( sol :: GrumpsSolution )</code></pre><p>Returns a vector of GrumpsEstimate types for θ that can be queried for results.  See  <em>getcoef</em>, <em>getstde</em>, <em>gettstat</em>, and <em>getname</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/sol.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getδ-Tuple{GrumpsSolution}" href="#Grumps.getδ-Tuple{GrumpsSolution}"><code>Grumps.getδ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getδ( sol :: GrumpsSolution )</code></pre><p>Returns a vector of GrumpsEstimate types for δ that can be queried for results. See  <em>getcoef</em>, <em>getstde</em>, <em>gettstat</em>, and <em>getname</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/sol.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getβ-Tuple{GrumpsSolution}" href="#Grumps.getβ-Tuple{GrumpsSolution}"><code>Grumps.getβ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getβ( sol :: GrumpsSolution )</code></pre><p>Returns a vector of GrumpsEstimate types for β that can be queried for results. See  <em>getcoef</em>, <em>getstde</em>, <em>gettstat</em>, and <em>getname</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/sol.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getcoef-Tuple{GrumpsEstimate}" href="#Grumps.getcoef-Tuple{GrumpsEstimate}"><code>Grumps.getcoef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getcoef( e :: GrumpsEstimate )</code></pre><p>Returns the estimated coefficient value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/sol.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getstde-Tuple{GrumpsEstimate}" href="#Grumps.getstde-Tuple{GrumpsEstimate}"><code>Grumps.getstde</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getstde( e :: GrumpsEstimate )</code></pre><p>Returns the standard error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/sol.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.gettstat-Tuple{GrumpsEstimate}" href="#Grumps.gettstat-Tuple{GrumpsEstimate}"><code>Grumps.gettstat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gettstat( e :: GrumpsEstimate )</code></pre><p>Returns the t statistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/sol.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getname-Tuple{GrumpsEstimate}" href="#Grumps.getname-Tuple{GrumpsEstimate}"><code>Grumps.getname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getname( e :: GrumpsEstimate )</code></pre><p>Returns the variable name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/sol.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getθcoef-Tuple{GrumpsSolution}" href="#Grumps.getθcoef-Tuple{GrumpsSolution}"><code>Grumps.getθcoef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getθcoef( sol :: GrumpsSolution )</code></pre><p>Returns a vector of θ coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/sol.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getδcoef-Tuple{GrumpsSolution}" href="#Grumps.getδcoef-Tuple{GrumpsSolution}"><code>Grumps.getδcoef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getδcoef( sol :: GrumpsSolution )</code></pre><p>Returns a vector of δ coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/sol.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getβcoef-Tuple{GrumpsSolution}" href="#Grumps.getβcoef-Tuple{GrumpsSolution}"><code>Grumps.getβcoef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getβcoef( sol :: GrumpsSolution )</code></pre><p>Returns a vector of β coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/types/sol.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Save-Tuple{AbstractString, Union{MIME{Symbol(&quot;text/tex&quot;)}, MIME{Symbol(&quot;text/csv&quot;)}, MIME{Symbol(&quot;text/plain&quot;)}}, Any}" href="#Grumps.Save-Tuple{AbstractString, Union{MIME{Symbol(&quot;text/tex&quot;)}, MIME{Symbol(&quot;text/csv&quot;)}, MIME{Symbol(&quot;text/plain&quot;)}}, Any}"><code>Grumps.Save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Save( fn, mt, sol :: GrumpsSolution; keywords... )</code></pre><p>Saves the solution stored in <code>sol</code> to a file with filename <code>fn</code> which has mime type <code>mt</code>.  </p><p>There are several keywords that are described below, some of which will be ignored for some mime types.  Allowed mime types are <code>text/plain</code>, <code>text/csv</code>, and <code>text/tex</code>.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>colsep</code></td><td style="text-align: left">column separator</td><td style="text-align: left"><code>&quot;,&quot;</code></td></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printθ</code></td><td style="text-align: left">print θ results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printβ</code></td><td style="text-align: left">print β results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printδ</code></td><td style="text-align: left">print δ results?</td><td style="text-align: left"><code>false</code></td></tr><tr><td style="text-align: left"><code>printconvergence</code></td><td style="text-align: left">convergence stats?</td><td style="text-align: left"><code>true</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/sol/sol.jl#L262-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Save-Tuple{AbstractString, Any}" href="#Grumps.Save-Tuple{AbstractString, Any}"><code>Grumps.Save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Save( fn, sol :: GrumpsSolution; keywords... )</code></pre><p>The same as the form of <code>Save</code> with prespecified mime type except that the mime type is now inferred from the file extension.  The keywords also have the same meaning, namely...</p><p>There are several keywords that are described below, some of which will be ignored for some mime types.  Allowed mime types are <code>text/plain</code>, <code>text/csv</code>, and <code>text/tex</code>.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>colsep</code></td><td style="text-align: left">column separator</td><td style="text-align: left"><code>&quot;,&quot;</code></td></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printθ</code></td><td style="text-align: left">print θ results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printβ</code></td><td style="text-align: left">print β results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printδ</code></td><td style="text-align: left">print δ results?</td><td style="text-align: left"><code>false</code></td></tr><tr><td style="text-align: left"><code>printconvergence</code></td><td style="text-align: left">convergence stats?</td><td style="text-align: left"><code>true</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/sol/sol.jl#L286-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, GrumpsEstimate{T}}, Tuple{IO, GrumpsEstimate{T}, String}} where T&lt;:AbstractFloat" href="#Base.show-Union{Tuple{T}, Tuple{IO, GrumpsEstimate{T}}, Tuple{IO, GrumpsEstimate{T}, String}} where T&lt;:AbstractFloat"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, e :: GrumpsEstimate{T}, s :: String = &quot;&quot;; keywords...)</code></pre><p>Show a <code>GrumpsEstimate</code> object on <code>io</code>; the argument <code>s</code> indicates which parameter family (θ,β,δ) the estimate belongs to.  The optional keywords are described in the table below.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printstde</code></td><td style="text-align: left">print standard errors?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printtstat</code></td><td style="text-align: left">print t statistics?</td><td style="text-align: left"><code>true</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/sol/sol.jl#L66-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, Array{GrumpsEstimate{T}, 1}}, Tuple{IO, Array{GrumpsEstimate{T}, 1}, String}} where T&lt;:AbstractFloat" href="#Base.show-Union{Tuple{T}, Tuple{IO, Array{GrumpsEstimate{T}, 1}}, Tuple{IO, Array{GrumpsEstimate{T}, 1}, String}} where T&lt;:AbstractFloat"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, est :: Vector{ GrumpsEstimate{T} }, s :: String = &quot;&quot;; keywords... )</code></pre><p>Shows a vector of estimates on <code>io</code> using the string <code>s</code> (typically one of θ,β,δ).  The command takes the following optional keywords.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printstde</code></td><td style="text-align: left">print standard errors?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printtstat</code></td><td style="text-align: left">print t statistics?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>header</code></td><td style="text-align: left">descriptive header?</td><td style="text-align: left"><code>false</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/sol/sol.jl#L105-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, GrumpsConvergence{T}}} where T&lt;:AbstractFloat" href="#Base.show-Union{Tuple{T}, Tuple{IO, GrumpsConvergence{T}}} where T&lt;:AbstractFloat"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, convergence :: GrumpsConvergence{T}; keywords...)</code></pre><p>Shows the contents of <code>convergence</code>, where the flags indicated what should be printed and how, as indicated in the following table.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>header</code></td><td style="text-align: left">descriptive header?</td><td style="text-align: left"><code>false</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/sol/sol.jl#L126-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, GrumpsSolution{T}}} where T&lt;:AbstractFloat" href="#Base.show-Union{Tuple{T}, Tuple{IO, GrumpsSolution{T}}} where T&lt;:AbstractFloat"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, sol :: GrumpsSolution{T}; keywords... )</code></pre><p>Shows the contents of <code>sol</code>, where the keywords indicate what should be printed and how, as described in the table below.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printθ</code></td><td style="text-align: left">print θ results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printβ</code></td><td style="text-align: left">print β results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printδ</code></td><td style="text-align: left">print δ results?</td><td style="text-align: left"><code>false</code></td></tr><tr><td style="text-align: left"><code>printconvergence</code></td><td style="text-align: left">convergence stats?</td><td style="text-align: left"><code>true</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/sol/sol.jl#L149-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MIME{Symbol(&quot;text/tex&quot;)}, GrumpsSolution}" href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/tex&quot;)}, GrumpsSolution}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, mt :: MIME{Symbol(&quot;text/tex&quot;)}, sol :: GrumpsSolution; keywords... )</code></pre><p>This is the same as <a href="#Grumps.Save-Tuple{AbstractString, Union{MIME{Symbol(&quot;text/tex&quot;)}, MIME{Symbol(&quot;text/csv&quot;)}, MIME{Symbol(&quot;text/plain&quot;)}}, Any}"><code>Save()</code></a> except that the contents are spit out on io (which could be <code>stdout</code> or an already opened file).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/sol/sol.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MIME{Symbol(&quot;text/csv&quot;)}, GrumpsSolution}" href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/csv&quot;)}, GrumpsSolution}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, mt :: MIME{Symbol(&quot;text/csv&quot;)}, sol :: GrumpsSolution; keywords... )</code></pre><p>This is the same as <a href="#Grumps.Save-Tuple{AbstractString, Union{MIME{Symbol(&quot;text/tex&quot;)}, MIME{Symbol(&quot;text/csv&quot;)}, MIME{Symbol(&quot;text/plain&quot;)}}, Any}"><code>Save()</code></a> except that the contents are spit out on io (which could be <code>stdout</code> or an already opened file).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/5e8633463e55fb6ccd7dbf0bba18b4cbf7b6384c/src/common/sol/sol.jl#L235-L240">source</a></section></article><h2 id="Memory-conservation"><a class="docs-heading-anchor" href="#Memory-conservation">Memory conservation</a><a id="Memory-conservation-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-conservation" title="Permalink"></a></h2><p><strong>stub; this section to be completed</strong></p><p>By default, Grumps loads all data and then creates space for all markets for things like choice probabilities, objective functions and their derivatives, intermediate objects, etcetera.  This saves computation time, but eats memory, especially as the number of random coefficients increases.</p><p>To conserve memory, one can set <code>memsave</code> in <a href="#Grumps.OptimizationOptions-Tuple{}"><code>OptimizationOptions()</code></a> to <code>true</code>.  What this does is that it shares space for choice probabilities and related objects across a number of markets.  For instance, if there are ten markets and the number of market threads in <a href="#Grumps.OptimizationOptions-Tuple{}"><code>OptimizationOptions()</code></a> is set to two then the space for choice probabilities is shared across five markets.  These choices will have no effect if the number of market threads is no less than the number of markets.  The downside of doing this is that it slows down computation since choice probabilities need to be recomputed.  This is especially true for estimators that use the penalty term.</p><p>There are less impactful ways of reducing memory usage, such as choosing the option <code>:Ant</code> for the micro data, also.  *** not yet implemented ***</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quick start</a><a class="docs-footer-nextpage" href="../spreadsheet/">Spreadsheet formats »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Saturday 29 April 2023 20:35">Saturday 29 April 2023</span>. Using Julia version 1.10.0-DEV.1149.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
