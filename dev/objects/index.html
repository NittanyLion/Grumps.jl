<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User interface · Grumps.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Grumps.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../estimators/">Estimators</a></li><li><a class="tocitem" href="../quickstart/">Quick start</a></li><li class="is-active"><a class="tocitem" href>User interface</a><ul class="internal"><li><a class="tocitem" href="#Data-entry"><span>Data entry</span></a></li><li><a class="tocitem" href="#Optimization-options"><span>Optimization options</span></a></li><li><a class="tocitem" href="#Data-storage-options"><span>Data storage options</span></a></li><li><a class="tocitem" href="#Standard-error-options"><span>Standard error options</span></a></li><li><a class="tocitem" href="#Estimator-choice"><span>Estimator choice</span></a></li><li><a class="tocitem" href="#Choice-of-integration-method-(integrators)"><span>Choice of integration method (integrators)</span></a></li><li><a class="tocitem" href="#Data-object-creation"><span>Data object creation</span></a></li><li><a class="tocitem" href="#Algorithm-call"><span>Algorithm call</span></a></li><li><a class="tocitem" href="#Retrieving-results"><span>Retrieving results</span></a></li></ul></li><li><a class="tocitem" href="../spreadsheet/">Spreadsheet formats</a></li><li><a class="tocitem" href="../example/">Example program</a></li><li><a class="tocitem" href="../tutorial/">Charlie&#39;s tutorial</a></li><li><a class="tocitem" href="../speedmemory/">Speed, memory, accuracy</a></li><li><a class="tocitem" href="../bearinmind/">Things to bear in mind</a></li><li><a class="tocitem" href="../extending/">Extending Grumps</a></li><li><a class="tocitem" href="../aliens/">Languages other than Julia</a></li><li><a class="tocitem" href="../structure/">Directory structure</a></li><li><a class="tocitem" href="../flow/">Algorithm flow</a></li><li><a class="tocitem" href="../misc/">Miscellanea</a></li><li><a class="tocitem" href="../acknowledgments/">Acknowledgments</a></li><li><a class="tocitem" href="../license/">License</a></li><li><a class="tocitem" href="../versions/">Versions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NittanyLion/Grumps.jl/blob/main/docs/src/objects.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="User-Interface"><a class="docs-heading-anchor" href="#User-Interface">User Interface</a><a id="User-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#User-Interface" title="Permalink"></a></h1><p>The sections below describe the main calls needed to use Grumps.  For any functions that are not documented here, simply use ? in the REPL, e.g. ?Variables.</p><p>The way that Grumps works is that one first specifies where the data are stored, what specification to use, which estimator to use, etcetera, before calling the functions that actually perform work with these choices.  All sections below up to and including the choice of integration method specify things, data object creation and algorithm call create and compute things, and the remainder deals with the retrieval of estimation results and memory conservation.</p><h2 id="Data-entry"><a class="docs-heading-anchor" href="#Data-entry">Data entry</a><a id="Data-entry-1"></a><a class="docs-heading-anchor-permalink" href="#Data-entry" title="Permalink"></a></h2><p>The methods below are used to enter data into Grumps.  With <a href="#Grumps.Sources-Tuple{}"><code>Sources()</code></a> one specifies where the data can be found and with <a href="#Grumps.Variables-Tuple{}"><code>Variables()</code></a> which variables to use from those data sources.  </p><div class="admonition is-success"><header class="admonition-header">Two versions of the Variables method</header><div class="admonition-body"><p>There are two versions of the <em>Variables</em> method, where the main difference is the syntax.  Use whichever one you prefer.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Grumps.Sources-Tuple{}" href="#Grumps.Sources-Tuple{}"><code>Grumps.Sources</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Sources( ;
    consumers   :: Any = nothing, 
    products    :: Any = nothing, 
    marketsizes :: Any = nothing, 
    draws       :: Any = nothing,
)</code></pre><p>Creates a GrumpsSources object with source type entries where the entries are provided in the optional parameters.</p><p>Grumps (potentially) uses four data sources: a data source for consumer-level data, one for product-level data, one for market size information, and one for demographic draws.  See <a href="../spreadsheet/#Spreadsheet-formats">Spreadsheet formats</a> for data layouts. Only the product-level data are required, but are by themselves insufficient.  For instance, for BLP95 one needs information on products, market sizes, and demographics; for the Grumps CLER estimator one needs all four types of data; for a multinomial logit both consumer and product information are needed.  Not all data are needed for all markets.  For instance, it is ok for some estimators for there to be consumer-level data in some markets but not others.</p><p>By default, the entries can be nothing, a string, a DataFrame, or a SourceFileType.  If an entry is nothing, it means that no such data is to be used.  If an entry is a string then it is converted to a SourceFileCSV entry with comma delimiter where the string name is the file name.  To use other source file types, create a SourceFileType first.  A DataFrame can be passed, also.  In all cases other than nothing, data will eventually be (converted to) a DataFrame and parsed from that.</p><p>The <em>consumers</em> variable specifies where consumer-level data can be found, the <em>products</em> variable is for the product-level data, <em>marketsizes</em> is for market sizes, and <em>draws</em> is for demographic draws.</p><p>Use the <a href="#Grumps.Variables-Tuple{}"><code>Variables()</code></a> method to specify the way the data sources are formatted and the specification to estimate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/source.jl#L38-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Variables-Tuple{}" href="#Grumps.Variables-Tuple{}"><code>Grumps.Variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Variables( ; 
  market              :: Symbol = :market,
  product             :: Symbol = :product,
  choice              :: Symbol = :choice,
  interactions        :: Mat{Symbol} = [],
  randomcoefficients  :: Vec{Symbol} = [],
  outsidegood         :: String = &quot;outsidegood&quot;,
  share               :: Symbol = :share,
  marketsize          :: Symbol = :N,
  regressors          :: Vec{Symbol} = [],
  instruments         :: Vec{Symbol} = [],
  dummies             :: Vec{Symbol} = [],
  nuisancedummy       :: Symbol = :none,
  microinstruments    :: Mat{Symbol} = [],
  user                :: Mat{Symbol} = []
    )</code></pre><p>This method is used to specify regressors, instruments, random coefficients, interactions, variable labels, etcetera, from the sources you have specified in <a href="#Grumps.Sources-Tuple{}"><code>Sources()</code></a>. It creates an object of type <em>GrumpsVariables</em>.</p><p>For instance, the option <em>market</em> specifies the column heading of the column containing the market descriptor (name).  The same is true for all other arguments, except <em>outsidegood</em> which describes the spreadsheet entry that indicates the product is an outside good.  The  same label for the outside good should be used in all spreadsheets and all markets. Outside good entries  should only be used in the consumer micro data and then only if there actually are consumers in the micro data choosing the outside good. All descriptors are case and space sensitive.</p><p>There is a separation between variables that go into the individual consumer utility and ones that only go into &quot;mean utility&quot;.  For instance, <em>interactions</em> tells Grumps which interaction terms to use and <em>randomcoefficients</em> which product level regressors are hit with a random coefficient.  By contrast, <em>regressors</em> go into the mean utility component and are regressors in the &quot;second stage&quot; (where β is recovered). One can use the special symbol <em>:constant</em> to indicate a constant is to be used; the spreadsheet need not include a column with that heading.</p><p>Note that there are three ways that dummy variables can be entered as second stage regressors, which can be useful to incorporate brand, firm, or market effects into δ.  The first is via <em>regressors</em>, in which case the onus is on the user to ensure that they have the correct numerical values.  The second possibility is via the <em>dummies</em> argument.  For  each symbol passed via the <em>dummiesi pass one via the *nuisancedummy</em> argument since it saves both computation time and memory.  There can only be at most one categorical variable that can be converted to nuisance dummies, but there can be arbitrarily many categories.  These dummies and nuisance dummies are automatically assumed to be exogenous and will be included in the instruments, also.</p><p><em>market</em> refers to the variable containing the market indicator in all input datasets.  Strings (e.g. &quot;Amarillo, Texas&quot;) work best for the market indicators themselves, but it is not a requirement.</p><p><em>product</em> refers to the variable containing the product indicator in the product dataset. Strings (e.g. &quot;Camry&quot;) work best for the product indicators themselves, but it is not a requirement.</p><p><em>choice</em> refers to the variable indicating the choice indicator in the consumer level datasets.  Strings work best for the choice indicators themselves, but it is not a requirement.  These should take the values of the <em>product</em> column in the products data set or of the <em>outsidegood</em>.</p><p><em>interactions</em> refers to the variables indicating consumer and product variable interactions (each row contains consumer variable, product variable)</p><p><em>randomcoefficients</em> refers to the product level variables that have a random coefficient on them</p><p><em>outsidegood</em> refers to the label used for the outside good</p><p><em>share</em> refers to the label used for the product level share; these are shares where the denominator includes the outside good</p><p><em>marketsize</em> refers to the size of the market (number of people)</p><p><em>regressors</em> refers to the label used for the second stage regressors</p><p><em>instruments</em> refers to the label used for the second stage instruments</p><p><em>dummies</em> refers to discrete variables to be converted to second stage dummy regressors and instruments</p><p><em>nuisancedummy</em> refers to at most one variable to be converted to a second stage dummy regressors and instrument whose coefficient value is of no interest</p><p><em>microinstruments</em> refers to micro instruments, which are only relevant for gmm style procedures</p><p><em>user</em> refers to a list of variables to be added to the consumer-product interactions using a user-specified procedure.  This is only needed if the Grumps specification itself does not suffice: see <a href="../extending/#Extending-Grumps">Extending Grumps</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/variables.jl#L49-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Variables-NTuple{4, String}" href="#Grumps.Variables-NTuple{4, String}"><code>Grumps.Variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Variables( 
    microspec           :: String,
    macrospec           :: String,
    dummyspec           :: String = &quot;&quot;,
    nuisancedummyspec   :: String = &quot;&quot;;
    market              :: String = &quot;market&quot;,
    product             :: String = &quot;product&quot;,
    outsidegood         :: String = &quot;outsidegood&quot;,
    marketsize          :: String = &quot;N&quot;,
    microinstruments    :: String = &quot;&quot;,
    user                :: String = &quot;&quot;
    )</code></pre><p>This method is used to specify regressors, instruments, random coefficients, interactions, variable labels, etcetera, from the sources you have specified in <a href="#Grumps.Sources-Tuple{}"><code>Sources()</code></a>. It creates an object of type <em>GrumpsVariables</em>.  There is another method by the same name that accomplishes much the same thing, but has a different user interface. </p><p>The method described here takes string arguments, including two mandatory ones, whereas the other method takes optional arguments only, mostly symbols, vectors of symbols, and matrices of symbols that can be passed in arbitrary order using keywords.  The current method parses user input before calling the other method.</p><p>The option <em>market</em> specifies the column heading of the column containing the market descriptor (name).  The same is true for all other  arguments, except <em>outsidegood</em> which describes the spreadsheet entry that indicates the product is an outside good.  The same label for  the outside good should be used in all spreadsheets and all markets. Outside good entries should only be used in the consumer micro data  and then only if there actually are consumers in the micro data choosing the outside good. All descriptors are case sensitive.</p><p>There is a separation between variables that go into the individual consumer utility and ones that only go into &quot;mean utility&quot;.  For instance, to specify what goes into individual consumer utility, one could specify</p><p>&quot;choice = loginc * msrp + famsize * logfootprint + famsize * van + urban * truck + rc * suv + rc * truck + rc * van&quot;</p><p>as the <em>microspec</em> argument to indicate that consumer choice is in the micro data set in a column headed &quot;choice&quot; and that there are four interaction terms and three random coefficients.  The interaction terms have the consumer-level variable as the first factor and the product  variable as the second argument.  In this example the three random coefficients are on the suv, truck, and van variables and these variable names should correspond to the column headings in the product level data set.  One can use <em>constant</em> to indicate a constant is used: there is no need to include a constant in one&#39;s data.</p><p>The <em>macrospec</em> argument takes the form </p><p>&quot;share = constant + logmpg + loghp + logfootprint + msrp | constant, logmpg, loghp, logfootprint, logcurbweight, lagplcon&quot;</p><p>where <em>share</em> are product-level market shares, everything between = and | represents regressors, and everything after | represents  instruments; both regressors and instruments are for the product level moments portion.  One can again use <em>constant</em> to indicate a constant is used, which need not be included in one&#39;s data.</p><p>For the remaining arguments, see the description of the other method <a href="#Grumps.Variables-Tuple{}"><code>Variables()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/variables.jl#L187-L234">source</a></section></article><h2 id="Optimization-options"><a class="docs-heading-anchor" href="#Optimization-options">Optimization options</a><a id="Optimization-options-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-options" title="Permalink"></a></h2><p>The default optimization options are sensible, in which case this section can be skipped.  But for those who want to play with tolerances and such, have at it.</p><p>There is one exception, however, and that exception pertains to using less memory.  There is a separate section dedicated to that possibility, namely <a href="../speedmemory/#Memory-conservation">Memory conservation</a></p><article class="docstring"><header><a class="docstring-binding" id="Grumps.OptimizationOptions-Tuple{}" href="#Grumps.OptimizationOptions-Tuple{}"><code>Grumps.OptimizationOptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OptimizationOptions(; 
θopt = OptimOptionsθ(), 
δopt = OptimOptionsδ(), 
threads = GrumpsThreads(), 
memsave = false, 
maxrepeats = 4, 
probtype = :fast,
id = :Grumps,
progressbar = true,
loopvectorization = true
)</code></pre><p>Sets the options used for numerical optimization.  <em>θopt</em> is used for the external optimization routine, <em>δopt</em> for the internal one.  These are both of type <em>OptimOptions</em>; see the <em>OptimOptionsθ</em> and <em>OptimOptionsδ</em> methods for elaboration.  The <em>memsave</em> variable is set to false by default; turning it on will reduce memory consumption significantly, but will also slow down computation.  The variable <em>maxrepeats</em> may disappear in the  future.  </p><p>There are two ways of computing choice probabilities: robust and fast, specified by passing <em>:robust</em> or <em>:fast</em> in <em>probtype</em>. Fast choice probabilities are the default for good reason.</p><p>The progressbar shows progress within an iteration in the form of colored circles at the top right hand corner of the screen. Loop vectorization is a new addition to Grumps and speeds up computation in most cases.</p><p>Finally, specifying id allows one to add callbacks, e.g. user functions that are called on each inner and  outer iteration.  See the <a href="../extending/#Extending-Grumps">Extending Grumps</a> portion of the documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L261-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.OptimOptionsθ-Tuple{}" href="#Grumps.OptimOptionsθ-Tuple{}"><code>Grumps.OptimOptionsθ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OptimOptionsθ(; 
f_tol = 1.0e-8, 
g_tol = 1.0e-4, 
x_tol = 1.0e-5, 
iterations = 25, 
show_trace = true, 
store_trace = true, 
extended_trace = true )</code></pre><p>Creates and returns an <em>OptimOptions</em> optimization options variable for the outer optimization algorithm, including the function value tolerance, the gradient tolerance, the solution tolerance, the maximum number of iterations, whether to show the trace, whether to store the trace, and whether to keep the extended trace.  See the <strong>Optim</strong> package for details.  </p><p>The current version of Grumps will largely ignore the trace-related parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L147-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.OptimOptionsδ-Tuple{}" href="#Grumps.OptimOptionsδ-Tuple{}"><code>Grumps.OptimOptionsδ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OptimOptionsδ( ; 
f_tol = 1.0e-8, 
g_tol = 1.0e-8, 
x_tol = 1.0e-6, 
iterations = 25, 
show_trace = false, 
store_trace = true, 
extended_trace = false )</code></pre><p>Creates and returns an <em>OptimOptions</em> optimization options variable for the inner optimization algorithm, including the function value tolerance, the gradient tolerance, the solution tolerance, the maximum number of iterations, whether to show the trace, whether to store the trace, and whether to keep the extended trace.  See the <strong>Optim</strong> package for details.  </p><p>The current version of Grumps will largely ignore the trace-related parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L167-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.GrumpsThreads-Tuple{}" href="#Grumps.GrumpsThreads-Tuple{}"><code>Grumps.GrumpsThreads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GrumpsThreads(; 
    blas = 0, 
    markets = 0, 
    inner = 0 
    )</code></pre><p>This sets the number of threads to be used subject to a number of caveats.  <em>blas</em> refers to the number of BLAS threads, <em>markets</em> to the number of threads in loops over markets, and <em>inner</em> to the number of threads in inner loops.  A value of zero forces the automatic selection of the number of threads.</p><p>Of these, <em>inner</em> is not currently used at all, <em>market</em> is only used in <em>memsave</em> mode, and <em>blas</em> is used.  However, please note that the number of threads used by Grumps altogether is the number of threads passed in via the command line argument (i.e. via the -t switch), where that number does not include the number of BLAS threads set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L199-L212">source</a></section></article><h2 id="Data-storage-options"><a class="docs-heading-anchor" href="#Data-storage-options">Data storage options</a><a id="Data-storage-options-1"></a><a class="docs-heading-anchor-permalink" href="#Data-storage-options" title="Permalink"></a></h2><p>The default data storage options are sensible, but some space can be saved by tinkering with the settings.  The only parameter that is worth changing in the first version of <code>DataOptions</code> is σ2, which is the variance of ξ, the product level error term.  This is of no relevance for two-stage estimators like unpenalized mle.</p><p>The second version of <code>DataOptions</code> is more flexible.  The first argument allows the user to specify a variance matrix for <span>$ξ$</span> to be used in the construction of the product level moment component of the objective function.  This choice is irrelevant in an exactly identified system.  In an overidentified system it does not matter for consistency, asymptotic normality, conformance, or the convergence rate of the estimators provided that it is positive definite and fixed.  It can affect efficiency.  The second argument allows the user to specify how standard errors should be computed and also causes Grumps to compute an estimate of <span>$V \xi$</span> that can be used as an input into a second stage.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.DataOptions-Tuple{}" href="#Grumps.DataOptions-Tuple{}"><code>Grumps.DataOptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataOptions(; 
    micromode   = :Hog
    macromode   = :Ant
    balance     = :micro
    σ2          = 1.0
    id          = :Grumps
)</code></pre><p>Both this method and the one described below specify how Grumps should store its data and what it should store.  This one is simpler but has less flexibility.  The first three options are best set to their defaults, unless you know what it is you&#39;re doing.  The <strong>σ2</strong> option is the variance of ξ, i.e. the error variance in the product level moments.  The <strong>id</strong> option is used to extend Grumps with other data constructions.</p><pre><code class="nohighlight hljs">DataOptions(
    VarξInput   :: VarξInput{T},
    VarξOutput  :: VarξOutput = VarξDefaultOutput,
    micromode   :: Symbol = :Hog,
    macromode   :: Symbol = :Ant,
    balance     :: Symbol = :micro,
    id          :: Symbol = :Grumps   
)</code></pre><p>Both this method and the one described above specify how Grumps should store its data and what it should store.  This one is both more complex and more flexible.  The <strong>micromode</strong>, <strong>macromode</strong>, and <strong>balance</strong> arguments are best kept at their defaults, unless you know what it is you&#39;re doing.  The <strong>id</strong> option is used to extend Grumps with other data constructions.  <strong>VarξInput</strong> is the variance matrix to be used in the penalty term weight matrix construction.  This should be a J by J matrix where J is the number of products across all markets.  Acceptable types for <strong>VarξInput</strong> include UniformScaling{T} (e.g. 1.0 * I ) and AbstractMatrix{T} (sparse matrix is recommended to conserve space, but a dense matrix is allowed).  <strong>VarξOutput</strong> is used to indicate what assumptions on the variance of ξ must be produced in the solution, which can subsequently be used as an input in a second stage if desirable; options are <em>VarξHomoskedastic</em>, <em>VarξHeteroskedastic</em>, <em>VarξClustering</em>, and <em>VarξUser</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L84-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.VarξInput" href="#Grumps.VarξInput"><code>Grumps.VarξInput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const VarξInput{T} = Union{ UniformScaling{T}, AbstractArray{T} }</code></pre><p>Type used to characterize the assumption under which the weight matrix for the product level moments component of the objective function should be computed.  This is irrelevant for consistency, conformance, or the convergence rate of the estimator but it can affect asymptotic efficiency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.VarξHomoskedastic" href="#Grumps.VarξHomoskedastic"><code>Grumps.VarξHomoskedastic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VarξHomoskedastic()</code></pre><p>Creates a variable of type VarξHomoskedastic.  This is used to indicate that standard errors should be computed under the assumption of homoskedasticity.  This choice does not affect efficiency.  It also products an estimate of the matrix V(ξ) as part of the solution object, which can be used as an input into a possible second stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.VarξHeteroskedastic" href="#Grumps.VarξHeteroskedastic"><code>Grumps.VarξHeteroskedastic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VarξHeteroskedastic()</code></pre><p>Creates a variable of type VarξHeteroskedastic.  This is used to indicate that standard errors should be computed under the assumption of heteroskedasticity.  This choice does not affect efficiency.  It also products an estimate of the matrix V(ξ) as part of the solution object, which can be used as an input into a possible second stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.VarξClustering" href="#Grumps.VarξClustering"><code>Grumps.VarξClustering</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VarξClustering( clusteron :: Symbol )</code></pre><p>Creates a variable of type VarξClustering.  This is used to indicate that standard errors should be computed under the assumption of clustering.  This choice does not affect efficiency.  It also products an estimate of the matrix V(ξ) as part of the solution object, which can be used as an input into a possible second stage.  The argument is the variable one should cluster on, e.g. <em>VarξClustering( :market )</em> suggests that Grumps should cluster on the variable contained in the column in the products spreadsheet with column heading <em>market</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.VarξUser" href="#Grumps.VarξUser"><code>Grumps.VarξUser</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VarξUser()</code></pre><p>Allows the user to specify its own standard error computation procedure.  Look at <code>Grumps.Template</code> to see how this is implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L45-L49">source</a></section></article><h2 id="Standard-error-options"><a class="docs-heading-anchor" href="#Standard-error-options">Standard error options</a><a id="Standard-error-options-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-error-options" title="Permalink"></a></h2><p>By default, Grumps computes standard errors for all coefficients.  This option allows one to change that.  For instance, standard errors may not be needed for all elements of <span>$\delta$</span>.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.StandardErrorOptions-Tuple{}" href="#Grumps.StandardErrorOptions-Tuple{}"><code>Grumps.StandardErrorOptions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StandardErrorOptions(; θ = true, δ = true, β = true )</code></pre><p>Specifies which coefficients to create standard errors for.  If you are looking for what type of standard errors to produce, look at <a href="#Grumps.DataOptions-Tuple{}"><code>DataOptions()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/options.jl#L301-L305">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Standard error type</header><div class="admonition-body"><p>If you are looking to change the way standard errors are computed, look at <a href="#Grumps.DataOptions-Tuple{}"><code>DataOptions()</code></a>.</p></div></div><h2 id="Estimator-choice"><a class="docs-heading-anchor" href="#Estimator-choice">Estimator choice</a><a id="Estimator-choice-1"></a><a class="docs-heading-anchor-permalink" href="#Estimator-choice" title="Permalink"></a></h2><p>Grumps can compute quite a few estimators and one can specify which estimator to use by passing the return value of a call to <code>Estimator</code> to the optimization routine.</p><p>The easiest way to call <code>Estimator</code> is by passing it a string that describes what it is that you want to do.  For a description of these estimators, see <a href="../estimators/#Estimators">Estimators</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.Estimator-Tuple{String}" href="#Grumps.Estimator-Tuple{String}"><code>Grumps.Estimator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Estimator( s :: String )</code></pre><p>Creates and returns a GrumpsEstimator type.  Grumps is reasonably good at figuring out what it is that you want, so e.g. <em>Estimator( &quot;maximum likelihood&quot; )</em> gives you the unpenalized Grumps maximum likelihood estimator.</p><p>The estimators currently programmed include:</p><ul><li>the full CLER estimator</li><li>a cheaper alternative to CLER that has the same limit distribution</li><li>MDLE, i.e CLER without product level moments</li><li>mixed logit with share constraints</li><li>mixed logit estimator using micro data only</li><li>GMM estimators of the same model (in progress: not recommended)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/est/est.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Estimator-Tuple{Symbol}" href="#Grumps.Estimator-Tuple{Symbol}"><code>Grumps.Estimator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Estimator( s :: Symbol )</code></pre><p>Creates and returns a GrumpsEstimator type.</p><p>This is one method of specifying the estimator used.  However, it is unforgiving in that the exact symbol used internally must be passed, so the <em>Estimator( s :: String )</em> method is usually a better choice.</p><p>Possible choices include:</p><p><em>:cler</em> the full CLER estimator  </p><p><em>:cheap</em> a cheaper alternative to CLER that has the same limit distribution</p><p><em>:mdle</em> MDLE, i.e CLER without product level moments</p><p><em>:shareconstraint</em> mixed logit with share constraints</p><p><em>:mixedlogit</em> mixed logit estimator using micro data only</p><p><em>:gmm</em>  GMM estimator of the same model (in progress: not recommended)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/est/est.jl#L33-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Estimators-Tuple{}" href="#Grumps.Estimators-Tuple{}"><code>Grumps.Estimators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Estimators( elaborate = false )</code></pre><p>Prints a list of available estimators.  The argument indicates whether a lot of features should be printed  or few.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/est/est.jl#L85-L90">source</a></section></article><h2 id="Choice-of-integration-method-(integrators)"><a class="docs-heading-anchor" href="#Choice-of-integration-method-(integrators)">Choice of integration method (integrators)</a><a id="Choice-of-integration-method-(integrators)-1"></a><a class="docs-heading-anchor-permalink" href="#Choice-of-integration-method-(integrators)" title="Permalink"></a></h2><p>Grumps uses separate integration methods for the micro and macro components. This section will discuss the default choices, which are the only integrators implemented as part of the package.  Users may implement their own integration routines, see <a href="../extending/#Adding-an-integrator">Adding an integrator</a>.   </p><p>For integrating the micro likelihood (over <span>$\nu$</span>), the default method is Hermitian quadrature which assumes <span>$\nu$</span> is standard normally distributed. Users may select the number of nodes per dimension. </p><p>For integrating the macro likelihood (over <span>$\nu$</span> and <span>$z$</span>), the default method is Monte Carlo integration. In this default, <span>$\nu$</span> is assumed to be standard normally distributed.  The distribution of <span>$z$</span> can either be (1) assumed to be standard normally distributed or (2) simulated using draws from its distribution provided by the user. Option (2) should be used in applications where a sample of <span>$z$</span> is available (e.g., consumer survey); the sample should be specified as the draws spreadsheet described in <a href="../spreadsheet/#Spreadsheet-formats">Spreadsheet formats</a>. </p><div class="admonition is-success"><header class="admonition-header">Default Integration</header><div class="admonition-body"><p>One gets defaults if the integrator arguments are omitted in the call to <a href="#Grumps.Data-Tuple{}"><code>Data()</code></a>.  The default integrators use a small number of nodes / draws in the sense that they emphasize speed / storage over accuracy, unless specified otherwise as documented below.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Grumps.DefaultMicroIntegrator-Tuple{Int64, Type}" href="#Grumps.DefaultMicroIntegrator-Tuple{Int64, Type}"><code>Grumps.DefaultMicroIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DefaultMicroIntegrator( n :: Int, T :: Type = Float64; options = nothing )</code></pre><p>Creates a basic quadrature Integrator using n nodes in each dimension.  Type T can be omitted, in which case it is Float64. The options variable is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/nodesweights.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.DefaultMicroIntegrator-Tuple{Type}" href="#Grumps.DefaultMicroIntegrator-Tuple{Type}"><code>Grumps.DefaultMicroIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DefaultMicroIntegrator( T :: Type; options = nothing )</code></pre><p>Creates a basic quadrature Integrator using 11 nodes in each dimension.   Type T can be omitted, in which case it is Float64.  The options variable is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/nodesweights.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.DefaultMacroIntegrator-Tuple{Int64, Type}" href="#Grumps.DefaultMacroIntegrator-Tuple{Int64, Type}"><code>Grumps.DefaultMacroIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DefaultMacroIntegrator( n :: Int, T :: Type; options :: Union{Vec{Symbol}, Nothing} = nothing )</code></pre><p>Creates a basic Monte Carlo Integrator using n draws.  Type T can be omitted, in which case it is Float64. The optional <em>options</em> argument can be used to indicate two possible changes from the default, namely <em>:randomize</em> can be used to require randomization and <em>:replacement</em> to indicate randomization with  replacement. The default for both is false. Note that <em>options</em> is either nothing or a vector of symbols.   A further use of <em>options</em> is to specify a column heading containing weight; this symbol should correspond to the desired column heading in the draws spreadsheet. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/nodesweights.jl#L102-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.DefaultMacroIntegrator-Tuple{Type}" href="#Grumps.DefaultMacroIntegrator-Tuple{Type}"><code>Grumps.DefaultMacroIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DefaultMacroIntegrator( T )</code></pre><p>Creates a basic Monte Carlo Integrator using 10 000 draws.  This is less than recommended, so use the other method to set a number of your choosing.  Type T can be omitted, in which case it is Float64. The optional <em>options</em> argument can be used to indicate two possible changes from the default, namely <em>:randomize</em> can be used to require randomization and <em>:replacement</em> to indicate randomization with  replacement.  Note that <em>options</em> is either nothing or a vector of symbols.  The defaults for both is false. A further use of <em>options</em> is to specify a column heading containing weight; this symbol should correspond to the desired column heading in the draws spreadsheet. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/nodesweights.jl#L136-L144">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Default macro integrator options and draws</header><div class="admonition-body"><p>Unless specified otherwise, the default macro integrator uses Monte Carlo integration with <span>$R = 10,000$</span> draws unless otherwise specified.  If one does not specify randomization then the default macro integrator simply uses the first <span>$R$</span> lines of draws for each market for demographics (<span>$z$</span> draws) and combines them with <span>$R$</span> draws from the distribution of the random coefficients (<span>$\nu$</span> draws), both of which are then interacted with the product level regressors (<span>$x$</span> variables).  If the spreadsheet does not contain enough rows corresponding to a market then the program will cycle and throw a warning.  With randomization with replacement, <span>$R$</span> numbers are drawn from the draws spreadsheet regardless of the number of lines in the spreadsheet.  Without replacement, the same occurs and if the spreadsheet does not contain enough lines corresponding to the market, all lines are added and then the procedure is repeated.  In other words, there is replacement by necessity.  Again, a warning will be displayed. With randomization, the random numbers are drawn separately for each market.</p></div></div><p>The remaining integration methods are only germane for GMM, which is in progress.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.MSMMicroIntegrator-Tuple{Int64, Type}" href="#Grumps.MSMMicroIntegrator-Tuple{Int64, Type}"><code>Grumps.MSMMicroIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MSMMicroIntegrator( n :: Int, T = F64; options = nothing )</code></pre><p>Creates a Monte Carlo integrator type for <em>micro</em> integration with GMM with smart moments.  The optional type can be omitted. The options variable is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/nodesweights.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.MSMMicroIntegrator-Tuple{Type}" href="#Grumps.MSMMicroIntegrator-Tuple{Type}"><code>Grumps.MSMMicroIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MSMMicroIntegrator( T = F64; options = nothing )</code></pre><p>Creates a Monte Carlo integrator type for <em>micro</em> integration with GMM with smart moments with 10 MC draws (per consumer). The type variable is optional and can be omitted.  The options variable is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/nodesweights.jl#L83-L88">source</a></section></article><h2 id="Data-object-creation"><a class="docs-heading-anchor" href="#Data-object-creation">Data object creation</a><a id="Data-object-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-object-creation" title="Permalink"></a></h2><p>The data stored in spreadsheets or other objects have to be converted into a form that Grumps understands.  The call to <code>Data</code> achieves that.   It takes as inputs the various choices made by the user and then creates an appropriate data object that is subsequently passed to the optimization call.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.Data-Tuple{}" href="#Grumps.Data-Tuple{}"><code>Grumps.Data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data( 
    e                   :: GrumpsEstimator,
    ss                  :: Sources,
    v                   :: Variables,
    microintegrator     :: MicroIntegrator = DefaultMicroIntegrator(),
    macrointegrator     :: MacroIntegrator = DefaultMacroIntegrator(),
    T                   :: Type = F64,
    options             :: DataOptions = GrumpsDataOptions(),
    replicable          :: Bool = true
    )</code></pre><p>Takes user inputs and converts them into an object that Grumps can understand.  This is synonymous with GrumpsData(...).</p><p><em>Data</em> takes the following arguments, of which the first three are mandatory:</p><ul><li><em>e</em>:                   estimator; see <a href="#Estimator-choice">Estimator choice</a></li><li><em>ss</em>:                  data sources; see <a href="#Data-entry">Data entry</a></li><li><em>v</em>:                   variables to be used; see <a href="#Data-entry">Data entry</a></li><li><em>o</em>:                   optimization options to be used   </li><li><em>microintegrator</em>:     micro integrator see <a href="#Choice-of-integration-method-(integrators)">Choice of integration method (integrators)</a></li><li><em>macrointegrator</em>:     macro integrator see <a href="#Choice-of-integration-method-(integrators)">Choice of integration method (integrators)</a></li><li><em>T</em>:                   floating point type; not heavily tested</li><li><em>u</em>:                   not yet implemented</li><li><em>options</em>:             data options to be used, see <a href="#Data-storage-options">Data storage options</a></li><li><em>replicable</em>:          whether results must be replicable (slows down speed of data creation if set to true)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/data/all.jl#L224-L250">source</a></section></article><div class="admonition is-success"><header class="admonition-header">Ensuring replicability</header><div class="admonition-body"><p>If you value replicability, set <code>replicable=true</code>. What it does is ensure that the same random numbers are fed into the integration routine.    This means that you will get exactly the same results if you run the program multiple times on the same computer with the same Grumps and Julia versions and the same versions of the included packages loaded and the same settings.  Achieving identical numbers beyond that is unrealistic.  However, differences should typically be small.</p><p>The downside of enforcing replicability is that it slows down data object generation since the data objects are then not generated in parallel.  Optimization itself will still be done in parallel however.</p></div></div><h2 id="Algorithm-call"><a class="docs-heading-anchor" href="#Algorithm-call">Algorithm call</a><a id="Algorithm-call-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-call" title="Permalink"></a></h2><p>Once all data structures have been put together, one can call the algorithm.  This is straightforward.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.grumps!-Union{Tuple{T}, Tuple{Estimator, Data{T}, OptimizationOptions, Union{Nothing, Vector{T}}, StandardErrorOptions}} where T&lt;:AbstractFloat" href="#Grumps.grumps!-Union{Tuple{T}, Tuple{Estimator, Data{T}, OptimizationOptions, Union{Nothing, Vector{T}}, StandardErrorOptions}} where T&lt;:AbstractFloat"><code>Grumps.grumps!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grumps!( 
    e       :: Estimator,
    d       :: Data{T},
    o       :: OptimizationOptions = OptimizationOptions(),
    θstart  :: StartingVector{T} = nothing,
    seo     :: StandardErrorOptions = StandardErrorOptions();
    printstructure = true
)</code></pre><p>Conducts the optimization.  You typically just want to set θstart to nothing, i.e. have a starting vector  picked automatically.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/optim/est.jl#L8-L20">source</a></section></article><h2 id="Retrieving-results"><a class="docs-heading-anchor" href="#Retrieving-results">Retrieving results</a><a id="Retrieving-results-1"></a><a class="docs-heading-anchor-permalink" href="#Retrieving-results" title="Permalink"></a></h2><p>As noted above, Grumps will return its results in a variable of type <code>GrumpsSolution</code> that can be queried or saved as follows.  You can also simply call one of the <code>print</code> or  related functions on any of these objects.</p><p>Finally, you can call any of <code>minimum</code>, <code>iterations</code>, <code>iteration_limit_reached</code>, <code>converged</code>, <code>f_converged</code>, <code>g_converged</code>, <code>x_converged</code>, <code>f_calls</code>, <code>g_calls</code>, <code>h_calls</code>, <code>f_trace</code>, <code>g_norm_trace</code>, <code>x_trace</code> on a <code>GrumpsSolution</code> object in the same way that you would query the return value in the <a href="https://github.com/JuliaNLSolvers/Optim.jl/">Optim package</a>, albeit that they are not in the namespace by default. E.g., if <code>sol</code> is a <code>GrumpsSolution</code> object,  use <code>Grumps.converged(sol)</code> instead of <code>converged(sol)</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Grumps.getθ-Tuple{GrumpsSolution}" href="#Grumps.getθ-Tuple{GrumpsSolution}"><code>Grumps.getθ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getθ( sol :: GrumpsSolution )</code></pre><p>Returns a vector of GrumpsEstimate types for θ that can be queried for results.  See  <em>getcoef</em>, <em>getstde</em>, <em>gettstat</em>, and <em>getname</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/sol.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getδ-Tuple{GrumpsSolution}" href="#Grumps.getδ-Tuple{GrumpsSolution}"><code>Grumps.getδ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getδ( sol :: GrumpsSolution )</code></pre><p>Returns a vector of GrumpsEstimate types for δ that can be queried for results. See  <em>getcoef</em>, <em>getstde</em>, <em>gettstat</em>, and <em>getname</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/sol.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getβ-Tuple{GrumpsSolution}" href="#Grumps.getβ-Tuple{GrumpsSolution}"><code>Grumps.getβ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getβ( sol :: GrumpsSolution )</code></pre><p>Returns a vector of GrumpsEstimate types for β that can be queried for results. See  <em>getcoef</em>, <em>getstde</em>, <em>gettstat</em>, and <em>getname</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/sol.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getcoef-Tuple{GrumpsEstimate}" href="#Grumps.getcoef-Tuple{GrumpsEstimate}"><code>Grumps.getcoef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getcoef( e :: GrumpsEstimate )</code></pre><p>Returns the estimated coefficient value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/sol.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getstde-Tuple{GrumpsEstimate}" href="#Grumps.getstde-Tuple{GrumpsEstimate}"><code>Grumps.getstde</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getstde( e :: GrumpsEstimate )</code></pre><p>Returns the standard error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/sol.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.gettstat-Tuple{GrumpsEstimate}" href="#Grumps.gettstat-Tuple{GrumpsEstimate}"><code>Grumps.gettstat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gettstat( e :: GrumpsEstimate )</code></pre><p>Returns the t statistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/sol.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getname-Tuple{GrumpsEstimate}" href="#Grumps.getname-Tuple{GrumpsEstimate}"><code>Grumps.getname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getname( e :: GrumpsEstimate )</code></pre><p>Returns the variable name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/sol.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getθcoef-Tuple{GrumpsSolution}" href="#Grumps.getθcoef-Tuple{GrumpsSolution}"><code>Grumps.getθcoef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getθcoef( sol :: GrumpsSolution )</code></pre><p>Returns a vector of θ coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/sol.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getδcoef-Tuple{GrumpsSolution}" href="#Grumps.getδcoef-Tuple{GrumpsSolution}"><code>Grumps.getδcoef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getδcoef( sol :: GrumpsSolution )</code></pre><p>Returns a vector of δ coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/sol.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.getβcoef-Tuple{GrumpsSolution}" href="#Grumps.getβcoef-Tuple{GrumpsSolution}"><code>Grumps.getβcoef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getβcoef( sol :: GrumpsSolution )</code></pre><p>Returns a vector of β coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/types/sol.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Save-Tuple{AbstractString, Union{MIME{Symbol(&quot;text/tex&quot;)}, MIME{Symbol(&quot;text/csv&quot;)}, MIME{Symbol(&quot;text/plain&quot;)}}, Any}" href="#Grumps.Save-Tuple{AbstractString, Union{MIME{Symbol(&quot;text/tex&quot;)}, MIME{Symbol(&quot;text/csv&quot;)}, MIME{Symbol(&quot;text/plain&quot;)}}, Any}"><code>Grumps.Save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Save( fn, mt, sol :: GrumpsSolution; keywords... )</code></pre><p>Saves the solution stored in <code>sol</code> to a file with filename <code>fn</code> which has mime type <code>mt</code>.  </p><p>There are several keywords that are described below, some of which will be ignored for some mime types.  Allowed mime types are <code>text/plain</code>, <code>text/csv</code>, and <code>text/tex</code>.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>colsep</code></td><td style="text-align: left">column separator</td><td style="text-align: left"><code>&quot;,&quot;</code></td></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printθ</code></td><td style="text-align: left">print θ results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printβ</code></td><td style="text-align: left">print β results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printδ</code></td><td style="text-align: left">print δ results?</td><td style="text-align: left"><code>false</code></td></tr><tr><td style="text-align: left"><code>printconvergence</code></td><td style="text-align: left">convergence stats?</td><td style="text-align: left"><code>true</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/sol/sol.jl#L262-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Grumps.Save-Tuple{AbstractString, Any}" href="#Grumps.Save-Tuple{AbstractString, Any}"><code>Grumps.Save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Save( fn, sol :: GrumpsSolution; keywords... )</code></pre><p>The same as the form of <code>Save</code> with prespecified mime type except that the mime type is now inferred from the file extension.  The keywords also have the same meaning, namely...</p><p>There are several keywords that are described below, some of which will be ignored for some mime types.  Allowed mime types are <code>text/plain</code>, <code>text/csv</code>, and <code>text/tex</code>.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>colsep</code></td><td style="text-align: left">column separator</td><td style="text-align: left"><code>&quot;,&quot;</code></td></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printθ</code></td><td style="text-align: left">print θ results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printβ</code></td><td style="text-align: left">print β results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printδ</code></td><td style="text-align: left">print δ results?</td><td style="text-align: left"><code>false</code></td></tr><tr><td style="text-align: left"><code>printconvergence</code></td><td style="text-align: left">convergence stats?</td><td style="text-align: left"><code>true</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/sol/sol.jl#L286-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, GrumpsEstimate{T}}, Tuple{IO, GrumpsEstimate{T}, String}} where T&lt;:AbstractFloat" href="#Base.show-Union{Tuple{T}, Tuple{IO, GrumpsEstimate{T}}, Tuple{IO, GrumpsEstimate{T}, String}} where T&lt;:AbstractFloat"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, e :: GrumpsEstimate{T}, s :: String = &quot;&quot;; keywords...)</code></pre><p>Show a <code>GrumpsEstimate</code> object on <code>io</code>; the argument <code>s</code> indicates which parameter family (θ,β,δ) the estimate belongs to.  The optional keywords are described in the table below.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printstde</code></td><td style="text-align: left">print standard errors?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printtstat</code></td><td style="text-align: left">print t statistics?</td><td style="text-align: left"><code>true</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/sol/sol.jl#L66-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, Array{GrumpsEstimate{T}, 1}}, Tuple{IO, Array{GrumpsEstimate{T}, 1}, String}} where T&lt;:AbstractFloat" href="#Base.show-Union{Tuple{T}, Tuple{IO, Array{GrumpsEstimate{T}, 1}}, Tuple{IO, Array{GrumpsEstimate{T}, 1}, String}} where T&lt;:AbstractFloat"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, est :: Vector{ GrumpsEstimate{T} }, s :: String = &quot;&quot;; keywords... )</code></pre><p>Shows a vector of estimates on <code>io</code> using the string <code>s</code> (typically one of θ,β,δ).  The command takes the following optional keywords.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printstde</code></td><td style="text-align: left">print standard errors?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printtstat</code></td><td style="text-align: left">print t statistics?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>header</code></td><td style="text-align: left">descriptive header?</td><td style="text-align: left"><code>false</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/sol/sol.jl#L105-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, GrumpsConvergence{T}}} where T&lt;:AbstractFloat" href="#Base.show-Union{Tuple{T}, Tuple{IO, GrumpsConvergence{T}}} where T&lt;:AbstractFloat"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, convergence :: GrumpsConvergence{T}; keywords...)</code></pre><p>Shows the contents of <code>convergence</code>, where the flags indicated what should be printed and how, as indicated in the following table.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>header</code></td><td style="text-align: left">descriptive header?</td><td style="text-align: left"><code>false</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/sol/sol.jl#L126-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, GrumpsSolution{T}}} where T&lt;:AbstractFloat" href="#Base.show-Union{Tuple{T}, Tuple{IO, GrumpsSolution{T}}} where T&lt;:AbstractFloat"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, sol :: GrumpsSolution{T}; keywords... )</code></pre><p>Shows the contents of <code>sol</code>, where the keywords indicate what should be printed and how, as described in the table below.</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>adorned</code></td><td style="text-align: left">make output pretty?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printθ</code></td><td style="text-align: left">print θ results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printβ</code></td><td style="text-align: left">print β results?</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>printδ</code></td><td style="text-align: left">print δ results?</td><td style="text-align: left"><code>false</code></td></tr><tr><td style="text-align: left"><code>printconvergence</code></td><td style="text-align: left">convergence stats?</td><td style="text-align: left"><code>true</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/sol/sol.jl#L149-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MIME{Symbol(&quot;text/tex&quot;)}, GrumpsSolution}" href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/tex&quot;)}, GrumpsSolution}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, mt :: MIME{Symbol(&quot;text/tex&quot;)}, sol :: GrumpsSolution; keywords... )</code></pre><p>This is the same as <a href="#Grumps.Save-Tuple{AbstractString, Union{MIME{Symbol(&quot;text/tex&quot;)}, MIME{Symbol(&quot;text/csv&quot;)}, MIME{Symbol(&quot;text/plain&quot;)}}, Any}"><code>Save()</code></a> except that the contents are spit out on io (which could be <code>stdout</code> or an already opened file).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/sol/sol.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MIME{Symbol(&quot;text/csv&quot;)}, GrumpsSolution}" href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/csv&quot;)}, GrumpsSolution}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show( io :: IO, mt :: MIME{Symbol(&quot;text/csv&quot;)}, sol :: GrumpsSolution; keywords... )</code></pre><p>This is the same as <a href="#Grumps.Save-Tuple{AbstractString, Union{MIME{Symbol(&quot;text/tex&quot;)}, MIME{Symbol(&quot;text/csv&quot;)}, MIME{Symbol(&quot;text/plain&quot;)}}, Any}"><code>Save()</code></a> except that the contents are spit out on io (which could be <code>stdout</code> or an already opened file).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NittanyLion/Grumps.jl/blob/3f85fa20e1a1672c53809e3b680560bfed763238/src/common/sol/sol.jl#L235-L240">source</a></section></article><div class="admonition is-success"><header class="admonition-header">Saving results to LaTeX</header><div class="admonition-body"><p>To save estimation results directly to a LaTeX tabular, just use a <code>.tex</code> extension in the filename.  For instance, write <code>Save( &quot;results.tex&quot;, sol )</code> if your solution is in the variable <code>sol</code>.</p></div></div><div class="admonition is-success"><header class="admonition-header">Saving output printed to terminal</header><div class="admonition-body"><p>To save the terminal output to html, one can use <a href="https://github.com/theZiz/aha">Aha</a>, the Ansi HTML Adapter, which is a small program (unrelated to Julia) that converts terminal output to html.  The way that would work on Linux and Mac (after successful installation) if one ran Grumps directly from the command line is to append <code>| aha &gt; myrun.html</code>, e.g. <code>julia -t auto myprogram.jl | aha &gt; myrun.html</code>.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quick start</a><a class="docs-footer-nextpage" href="../spreadsheet/">Spreadsheet formats »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 19 August 2023 22:00">Saturday 19 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
